
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Flutter Codelab / Coding Roulette: Architecting your Flutter Apps Workshop (pt.2): Creating the Landing Page</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements-tmp/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="flutter-codelab-cr2-2"
                  title="Flutter Codelab / Coding Roulette: Architecting your Flutter Apps Workshop (pt.2): Creating the Landing Page"
                  environment="web"
                  feedback-link="https://romanjustcodes.web.app">
    
      <google-codelab-step label="Overview" duration="0">
        <h2 is-upgraded>What You&#39;ll Build in this Workshop:</h2>
<ul>
<li>A Landing Page composed of multiple child widgets (AppBar, Drawer, DonutBottomBar, DonutFilterBar, DonutList with DonutCards, DonutPager, PageViewIndicator)</li>
<li>Create Flutter User interfaces with ease</li>
<li>Common Flutter Layout strategies using just core widgets</li>
<li>Creating custom Flutter widgets and achieve widget composition</li>
<li>Creating Dart models to mock up app data</li>
<li>Import network images</li>
<li>Using Material Icon fonts</li>
<li>State Management using Provider to decouple Business Logic of Components (BLoC), and widgets such as Consumer, Provider, MultiProvider, ChangeNotifierProvider</li>
<li>Animations in Flutter using core Animated Widgets, AnimationControllers and Tweens</li>
<li>Stateful and Stateless Widgets</li>
<li>Nested Navigation using the Navigator Widget</li>
</ul>
<p>In this part of the workshop (pt.2) we will tackle the landing page (see image below). If you are here, make sure you have completed <a href="https://romanejaquez.github.io/flutter-codelab-cr2-1" target="_blank">pt.1</a> of this series.</p>
<p class="image-container"><img alt="Landing Page" src="img/3c66d5071dfeeef1.gif"></p>
<p>We will tackle several aspects during this codelab for this page in particular:</p>
<ul>
<li><strong>Achieve Widget Composition</strong>: we will separate each feature into its separate widget and tackle it separately.</li>
<li><strong>Nested Navigation</strong>: We will be diving into Nested Navigation where we will not only navigate through the main pages of the app (using the app&#39;s root Navigation Stack), but also create pages that will be pushed onto a nested &#34;stack&#34; (inside a page&#39;s own internal Navigation Stack, or a &#34;child&#34; stack) by using the <a href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" target="_blank"><strong>Navigator</strong></a> widget.</li>
<li><strong>Introduce </strong><a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/intro" target="_blank"><strong>State Management</strong></a><strong> in Flutter (using Provider)</strong>: since widgets either encapsulate their state or share it across widgets throughout the application, you want to establish a good strategy, as well as separate the business logic from your widget rendering logic. We will be exploring the <a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple" target="_blank">Provider</a> as a simple yet robust state management strategy that applies to most use cases.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Set up the Landing Page&#39;s Scaffold" duration="0">
        <p>First things first, we want to establish a good foundation for the landing page (which we&#39;re calling <strong>DonutShopMain</strong>), since this is where many of our feature widgets will reside (and even communicate with one another in a decoupled fashion).</p>
<p>This is what we&#39;ll set up initially as the base:</p>
<p class="image-container"><img alt="Landing Page" src="img/76bb25f45ac2b540.png"></p>
<p>Let&#39;s continue expanding on our landing page <strong>DonutShopMain</strong>, where in the <a href="https://romanejaquez.github.io/flutter-codelab-cr2-1" target="_blank">previous codelab</a> we created it as a dummy page widget. We&#39;ll flesh it out more now.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Create the App Bar" duration="0">
        <p>Let&#39;s start from the top of the <strong>Scaffold</strong>, where we&#39;ll create the application bar. See the schematics below:</p>
<p class="image-container"><img alt="Landing Page" src="img/e7dc9444567839b4.png"></p>
<p>Now, let&#39;s start coding it!</p>
<p>In the <strong>DonutShopMain</strong> widget&#39;s <strong>Scaffold</strong> widget, set its <strong>appBar</strong> to a new instance of <strong>AppBar</strong>:</p>
<p class="image-container"><img alt="Landing Page" src="img/d63af5b1043e833f.png"></p>
<p>Proceed to set the rest of the options as follows:</p>
<ul>
<li>iconTheme: set it to an <strong>IconThemeData</strong> object witht color <strong>Utils.mainDark</strong></li>
<li>backgroundColor: set it to <strong>Colors.transparent</strong></li>
<li>elevation: set it to zero (0) so it doesn&#39;t show a shadow</li>
<li>centerTitle: set it to <strong>true</strong> to ensure centering</li>
<li>title: instead of text, set it to be an image to it stays in line with the app&#39;s theme (use an <strong>Image.network</strong> with width 120px)</li>
</ul>
<p class="image-container"><img alt="Landing Page" src="img/24f2c9d7fe48ef08.png"></p>
<p>Running the app at this point should get you the following output:</p>
<p class="image-container"><img alt="Landing Page" src="img/f1f4ff47ef59a689.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Adding a Drawer" duration="0">
        <p class="image-container"><img alt="Landing Page" src="img/3f7ed42a36426456.gif"></p>
<p>We&#39;ll be adding a <strong>Drawer</strong> widget (like a sliding side menu triggered by a hamburger menu) by first creating a simple widget that encapsulates this functionality. You can expand further on this side menu - we&#39;ll just add a couple of images on a background, just to show you how to implement it and then append it to the <strong>Scaffold</strong>.</p>
<p>Create a new custom widget that extends <strong>StatelessWidget</strong> called <strong>DonutSideMenu</strong>. Override its <strong>build</strong> method and return an empty <strong>Container</strong> for now:</p>
<p class="image-container"><img alt="Landing Page" src="img/ed10e467600124a8.png"></p>
<p>Let&#39;s dig into its structure. To the existing <strong>Container</strong>, set its <strong>color</strong> property to a predefined one (<strong>Utils.mainDark</strong>), and add 40px of padding all around it:</p>
<p class="image-container"><img alt="Landing Page" src="img/d8ea1b515547506.png"></p>
<p>As the <strong>child</strong> of this <strong>Container</strong>, add a <strong>Column</strong> with two <strong>Image</strong> widgets:</p>
<p class="image-container"><img alt="Landing Page" src="img/9199b30f19c0a2b2.png"></p>
<p>Make sure both images are left aligned and spread apart vertically by setting the <strong>Column</strong> properties of <strong>crossAxisAlignment</strong> and <strong>mainAxisAlignment</strong> to *start** and <strong>spaceBetween</strong> respectively:</p>
<p class="image-container"><img alt="Landing Page" src="img/870e9e217a51b9bf.png"></p>
<p>To the top image, wrap it inside a <strong>Container</strong> so we can add a top margin of 40px to give it more breathing room:</p>
<p class="image-container"><img alt="Landing Page" src="img/873b2a7eb669e719.png"></p>
<p>I think we&#39;re pretty much done with it. Now let&#39;s go ahead and use it in our <strong>Scaffold</strong>.</p>
<p>Set the <strong>drawer</strong> property of the <strong>Scaffold</strong> to a <strong>Drawer</strong> widget, and set the <strong>child</strong> of the drawer widget our newly created <strong>DonutSideMenu</strong> widget, as such:</p>
<p class="image-container"><img alt="Landing Page" src="img/853065d671f418c3.png"></p>
<p>Running it on Dartpad, we should see the following on the preview panel:</p>
<p class="image-container"><img alt="Landing Page" src="img/9bb6aa7439445cd7.gif"></p>
<p>We see the hamburger menu show once we set the <strong>Drawer</strong>, and tapping on it expands our newly created widget. Sweet! Let&#39;s proceed.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Set Up the Scaffold&#39;s body" duration="0">
        <p class="image-container"><img alt="Landing Page" src="img/4361f9dce8b4788f.png"></p>
<p>We want to distribute the <strong>Scaffold</strong>&#39;s body appropriately so it can accommodate the child pages that will be displayed in the landing page child stack as well as the bottom navigation bar that will trigger the swapping / navigating among those pages.</p>
<p>We&#39;ll distribute the body into the main content, for which we&#39;ll use an <strong>Expanded</strong> widget so it can take up most of the real estate of the body, followed by a placeholder <strong>Container</strong> widget (that will later be replaced by the bottom navigation bar).</p>
<p>Replace the contents of the <strong>Scaffold</strong>&#39;s body (currently a <strong>Center</strong> widget wrapping a <strong>Text</strong> widget) by a <strong>Column</strong>, holding an <strong>Expanded</strong> and a placeholder <strong>Container</strong> widget, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/32afcb7ea5fde6fb.png"></p>
<p>We should be all set to proceed to the next step, which is creating the bottom navigation bar for the landing page.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Create the Bottom Navigation Bar: UI" duration="0">
        <p class="image-container"><img alt="Landing Page" src="img/2e48300bc7f9d038.gif"></p>
<p>This widget will reflect which bar item is selected, trigger the child navigation stack so as to display the corresponding associated child page, as well as keep count of how many items have been added to the shopping cart (a nice-to-have we will implement when we get to the shopping cart functionality).</p>
<p>Let&#39;s proceed!</p>
<p>As before, we&#39;ll create a custom widget for this bottom bar to achieve a unique experience. Create a class called <strong>DonutBottomBar</strong> that extends <strong>StatelessWidget</strong>. Override its <strong>build</strong> method and return a <strong>Container</strong> with 30px padding all inside.</p>
<p class="image-container"><img alt="Landing Page" src="img/68ed8130a6e4c479.png"></p>
<p>As the child of the <strong>Container</strong>, add a <strong>Row</strong> widget, with its <strong>crossAxisAlignment</strong> set to <strong>end</strong> and <strong>mainAxisAlignment</strong> set to <strong>spaceBetween</strong> so its children are aligned at the bottom, and spread apart:</p>
<p class="image-container"><img alt="Landing Page" src="img/19396cd8a5a078c1.png"></p>
<p>Now, as the children of the <strong>Row</strong> widget, set three <strong>IconButton</strong> widgets, with the <strong>icon</strong> property set to your desired icons, with color <strong>Utils.mainColor</strong> initially, and the <strong>onPressed</strong> event set to empty (since its mandatory):</p>
<p class="image-container"><img alt="Landing Page" src="img/5d1baf2fce1e39a5.png"></p>
<p>This is a good spot for us to test what we&#39;ve done so far.</p>
<p>Go back to the <strong>DonutShopMain</strong> page widget and replace the placeholder <strong>Container</strong> widget below the <strong>Expanded</strong> widget:</p>
<p class="image-container"><img alt="Landing Page" src="img/a06a0c5997b55aa6.png"></p>
<p>Running it on DartPad, it should look like this once plugged in:</p>
<p class="image-container"><img alt="Landing Page" src="img/3fcc01df6fe38828.gif"></p>
<p>Now, let&#39;s add the selection functionality.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Create the Bottom Navigation Bar: Selection" duration="0">
        <p>Now in order to persist the selection of the currently selected item in the bottom bar, we can tackle it multiple ways:</p>
<ul>
<li>Create it as a <strong><em>StatefulWidget</em></strong>: we persist the value of the currently selected item as internal state, and rebuild the widget based on that, then color the selected item appropriately. The only issue with this is that the state will stay internal to the widget and the selection won&#39;t be persisted across page navigations.</li>
<li>Create a <strong>Provider</strong> service called <strong>DonutBottomBarSelectionService</strong> which will &#34;lift the state up&#34; and use a <strong>Consumer</strong> widget that when changes to the selected bottom bar item occur, re-render the widget. This is the most feasible and robust approach, as the selection will be maintained outside of the widget, and will persist across widget rebuilds and page navigations. This is based on the <strong>provider</strong> package, which leverages the <strong>InheritedWidget</strong> way of &#34;providing&#34; information to &#34;consumers&#34; down the widget hierarchy, in a uni-directional data flow.</li>
</ul>
<p>Let&#39;s proceed.</p>
<aside class="special"><p>Ignore the following step if you&#39;re doing this codelabs on Dartpad, since Dartpad already comes with the <strong>provider</strong> package pre-installed. Yay!</p>
</aside>
<h2 is-upgraded>Import the provider service (IGNORE IF USING DARTPAD)</h2>
<p>In your project&#39;s <strong>pubspec.yaml</strong> add a dependency to the <strong>provider</strong> package. Add the latest version to it:</p>
<p class="image-container"><img alt="Landing Page" src="img/c736ff78832a0ee0.png"></p>
<p>Perform a <strong>flutter pub get</strong> or save the <strong>pubspec.yaml</strong> to trigger an update to its dependencies.</p>
<h2 is-upgraded>Import the provider package in your implementing classes</h2>
<p>Whenever you&#39;re using any of the <strong>Provider</strong> classes (<strong><em>Provider, ChangeNotifierProvider, ChangeNotifier, Consumer, etc.</em></strong>) then import the provider package:</p>
<pre><code language="language-flutter" class="language-flutter">import &#39;package:provider/provider.dart&#39;;

</code></pre>
<h2 is-upgraded>Create a Provider Service to hold the Bottom Bar Selection</h2>
<p>Create a class called <strong>DonutBottomBarSelectionService</strong> that extends <strong>ChangeNotifier</strong>. The <strong>ChangeNotifier</strong> class provides change notification capabilities for those interested widgets in knowing when changes occur in any of their properties, which is accomplished by calling its <strong>notifyListeners</strong> method.</p>
<p>We are interested in storing what the current bottom bar item selection is at any given time, so we&#39;ll store that in a variable called <strong>tabSelection</strong>, type <strong>string</strong>. We&#39;ll have a default value of &#34;main&#34; which means there will be a bottom bar item named &#34;main&#34; that will always be selected by default.</p>
<p>We will provide a handy setter method called <strong>setTabSelection</strong> that takes the new selection, and right after storing the new value, we will invoke <strong>notifyListeners</strong>, which notifies any listening widgets (i.e. <strong>Consumer</strong> widget) to rebuild based on the new changes.</p>
<p>See the class implementation below:</p>
<pre><code language="language-flutter" class="language-flutter">class DonutBottomBarSelectionService extends ChangeNotifier {

  String? tabSelection = &#39;main&#39;;

  void setTabSelection(String selection) {
    tabSelection = selection;
    notifyListeners();
  }
}

</code></pre>
<h2 is-upgraded>Inject the Provider Service at the Root of the App</h2>
<p>In order to give this provider service a global scope so it &#34;provides&#34; itself or trickles down to interested widgets in the hierarchy, you have to lift the state as high as you can; in our case we&#39;ll inject it at the very top - at the <strong>MaterialApp</strong> level. This sets app-level scope, as opposed to scoping it to the widget in which it is used.</p>
<aside class="special"><p>When the scope of the provider service is set to a consuming widget, all widgets on the widget tree underneath it will be able to access it, hence the reason why <strong>Provider</strong> is a wrapper around the <a href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html" target="_blank"><strong>InheritedWidget</strong></a> implementation, which efficiently propagates information down the widget tree.</p>
</aside>
<p>Since we will be using more than one provider service in this app, let&#39;s use a <strong>MultiProvider</strong> widget, otherwise for a single-provider app or a locally-scoped service, a <strong>Provider</strong> or <strong>ChangeNotifierProvider</strong> widget would do.</p>
<p>Wrap the <strong>MaterialApp</strong> inside a <strong>MultiProvider</strong> widget, and set its <strong>providers</strong> property to an empty array to start with (and make sure to import the <strong>provider</strong> package):</p>
<p class="image-container"><img alt="Landing Page" src="img/1ca655f72259b450.png"></p>
<p>Let&#39;s add our first provider service, the <strong>DonutBottomBarSelectionService</strong> wrapped inside a <a href="https://pub.dev/documentation/provider/latest/provider/ChangeNotifierProvider-class.html" target="_blank"><strong>ChangeNotifierProvider</strong></a> object:</p>
<p class="image-container"><img alt="Landing Page" src="img/115d184dd8186c88.png"></p>
<aside class="special"><p>By providing the <strong>DonutBottomBarSelectionService</strong> at this level, we ensure all widgets down the hierarchy have access to this service.</p>
</aside>
<h2 is-upgraded>Consume the Service in the DonutBottomBar widget</h2>
<p>Now that the service has been <strong><em>provided</em></strong> at the root, since the <strong>DonutBottomBar</strong> widget is a widget located down the hierarchy, we know for sure this service will trickle down to it. In order to <strong><em>consume</em></strong> it - listen to changes occurring when the tab selection changes (i.e. the <strong>setTabSelection</strong> method gets called), we will use a convenient widget called <strong>Consumer</strong>. The <strong>Consumer</strong> widget rebuilds itself when the <strong>notifyListeners</strong> method of the service it is listening to gets called.</p>
<p>We&#39;ll put the <strong>Consumer</strong> widget inside the <strong>DonutBottomBar</strong> widget, more precisely around the <strong>Row</strong> widget that holds our bar items (<strong><em>IconButtons</em></strong>), that way when the selection changes (when the user taps on the corresponding <strong>IconButton </strong></p>
<p><strong><em>onPressed</em></strong> event), we appropriately set the selected one, which triggers the <strong>notifyListeners</strong>, which in turns forces itself to rebuild; then upon the widget rebuilding, the new selected tab value gets evaluated, and we change the color of the selected one accordingly.</p>
<p class="image-container"><img alt="Landing Page" src="img/d2f1796fc7c55081.png"></p>
<p>Notice how we make the <strong>Consumer</strong> widget a direct child of the main <strong>Container</strong> widget in the bottom bar, which in turn returns the <strong>Row</strong> widget from its <strong>builder</strong> callback method. This callback provides a context, an instance of the service being listened to (bottomBarSelectionService) and an optional child.</p>
<p>Now, let&#39;s make each one of the <strong>IconButton</strong> widgets trigger the <strong>Consumer</strong> to rebuild, by using the provided service instance (bottomBarSelectionService) and its provided method <strong><em>setTabSelection</em></strong> and passing the corresponding value of the selected tab item:</p>
<p class="image-container"><img alt="Landing Page" src="img/766747d8c1a30a8c.png"></p>
<p>Each button will call up to the service, set the value, and thus invoking the <strong>notifyListeners</strong> method, which will cause the <strong>Consumer</strong> widget to rebuild. Now how do we evaluate the selected value upon each rebuild, and in turn change the color of the <strong>Icon</strong> widget in the <strong>IconButton</strong> widget accordingly?</p>
<p>Simply read the <strong>tabSelection</strong> property on each turn of the <strong>build</strong> method, and change the color of the <strong>Icon</strong> whether the item in question matches the selection, as such (apply this to all <strong>Icon</strong> widgets for each <strong>IconButton</strong> widget accordingly):</p>
<p class="image-container"><img alt="Landing Page" src="img/deb3c16c812632af.png"></p>
<p>Running on DartPad to test the selection, notice how when each <strong>IconButton</strong> is clicked, the color of the child <strong>Icon</strong> changes to dark when it is the one being selected, while the rest change to a lighter color, efficiently proving that the state is being lifted and maintained outside of the widget, regardess of it rebuilding on every click.</p>
<p class="image-container"><img alt="Landing Page" src="img/6e43a0251ac6dcd2.gif"></p>
<p>Nicely done, and great introduction to <strong><em>State Management using Provider</em></strong> in Flutter!</p>
<p>Let&#39;s keep rolling!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Nested Navigation Strategy: Set Up the Landing Page Child Navigation" duration="0">
        <p>We will now implement a way in which, without leaving the <strong>DonutShopMain</strong> landing page widget, we can swap out content, by using the <strong>Navigator</strong> widget, which sets up a child navigation stack private to this page, but triggered by an external component (the <strong>DonutBottomBar</strong> widget).</p>
<p class="image-container"><img alt="Landing Page" src="img/2bd5483503934a31.gif"></p>
<p>When a user clicks on a bottom bar navigation item, it will push a new child page onto the nested navigation stack in our landing page. The <strong>Navigator</strong> widget in the <strong>DonutShopMain</strong> page will switch between three sub-pages (main list, favorites list, shopping list). Let&#39;s see how it&#39;s done!</p>
<p class="image-container"><img alt="Landing Page" src="img/ef2fbd33fa2612b6.png"></p>
<p>The main application contains its own Navigation Stack - that&#39;s how it accomplish navigating between the pages it&#39;s composed of (in our case, the <strong>SplashPage</strong> widget and the <strong>DonutShopMain</strong> pages are pushed onto the main app navigation stack - even the <strong>Drawer</strong> gets pushed to the main navigation stack ;) - go figure!).</p>
<p>Pages get pushed (in a stack fashion) one on top of the other, the topmost page being the one the user sees at a given time. Pages get popped off the top of the stack, revealing the one underneath until there&#39;s no more pages to pop, and so on.</p>
<p>However, pages can implement their own navigation stack - allowing child pages to be displayed within them with the help of the <strong>Navigator</strong> widget, which works similar to the main app navigation stack, allowing pages to be pushed onto it, etc. More on nested navigation <a href="https://flutter.dev/docs/cookbook/effects/nested-nav" target="_blank">here</a>.</p>
<h2 is-upgraded>Set Up the Plumbing for the Navigation Strategy</h2>
<p>We will have to do some refactoring in order to manage both navigation stacks (main nav stack, and landing page nav stack) independently, but efficiently.</p>
<p>Each navigation stack will be referenced by a unique global key, so that we can uniquely reference them and be able to push and pop widgets on and off of it efficiently.</p>
<p>In the <strong>Utils</strong> class we created earlier, start by defining two <strong>GlobalKey</strong> instances, each of which will be assigned to each navigation stack:</p>
<p class="image-container"><img alt="Landing Page" src="img/521e7d768518d7f.png"></p>
<h2 is-upgraded>Refactor the Main Navigation / Set up Routes</h2>
<p>Let&#39;s do some refactoring to the main navigation strategy, and instead of pushing instances of <strong>Route</strong> that get pushed onto the navigation stack, we will instead use <a href="https://flutter.dev/docs/cookbook/navigation/named-routes" target="_blank"><strong>named routes</strong></a>.</p>
<p>Go to the <strong>MaterialApp</strong> widget. Remove the <strong>home</strong> property which points to the <strong>SplashPage</strong> widget. Add the following properties:</p>
<ul>
<li>initialRoute: sets up what the initial named route of the app should be. Set it to &#34;/&#34; to denote the default route.</li>
<li>navigatorKey: this is the key that uniquely identifies the navigator stack. We will programmatically reference this navigator stack by calling <strong>Utils.mainAppNav</strong> (for the main app navigation stack) or <strong>Utils.mainListNav</strong> for the nested navigator stack in the <strong>DonutShopMain</strong> page.</li>
<li>routes: dictionary with key-value pairs; the key will represent the name of the route, and the value will be a callback that returns the corresponding widget to push onto the stack.</li>
</ul>
<p>Your code should look like this afterwards:</p>
<p class="image-container"><img alt="Landing Page" src="img/30ca1c4f139230f6.png"></p>
<p>Let&#39;s take this for a spin! In the <strong>SplashPageState</strong> class, we are currently pushing the <strong>DonutShopMain</strong> page by creating a <strong>Route</strong> instance which wraps the corresponding widget, then pushing it onto the navigation stack.</p>
<p>Replace this by using the named route approach; use <strong>Utils.mainAppNav.currentState!.pushReplacementNamed(â€˜/main&#39;)</strong>, which pushes the widget page associated with the route key named &#34;main&#34;, hence beign a &#34;named&#34; route. Your navigation code should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/3b0abfc831fd69f8.png"></p>
<p>Running this code should not display anything different from what it was before - the <strong>SplashPage</strong> gets displayed, then after 2 seconds, it navigates to the <strong>DonutShopMain</strong> page, this time being done via a <strong><em>named route</em></strong>, but yielding the same results.</p>
<p>And with that in place, we are ready to set up the <strong>Navigator</strong> widget and our nested navigation strategy!</p>
<h2 is-upgraded>Add the Navigator Widget to the DonutShopMain Landing Page</h2>
<p>Let&#39;s go to the <strong>DonutShopMain</strong> widget page; inside the <strong>Expanded</strong> widget, replace the child <strong>Container</strong> widget by a <strong>Navigator</strong> widget.</p>
<p class="image-container"><img alt="Landing Page" src="img/e9468747bed3a98.png"></p>
<p>Inside the <strong>Navigator</strong> widget, set its <strong>key</strong> property (<strong><em>Utils.mainListNav</em></strong>) and its <strong>initialRoute</strong> (&#34;/&#34;) - just like the main navigator (yes, even a child navigator has an <strong>initialRoute</strong> so it knows which page to land on initially by default). We&#39;ll set up its routes as well.</p>
<p class="image-container"><img alt="Landing Page" src="img/f30ba489ffa571c8.png"></p>
<p>In order to set up the routes managed by this <strong>Navigator</strong> widget, you must hook up to its <strong>onGenerateRoute</strong> callback, which gets triggered when a user pushes a named route onto this child navigation stack, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/65de05ab44fc8146.png"></p>
<p>When a user calls <strong>Utils.mainListNav.currentState.pushNamed()</strong> and pass the named route belonging to this child navigation stack, the <strong>onGenerateRoute</strong> gets invoked. Its <strong>settings</strong> parameter type <strong>RouteSettings</strong> has a property called <strong>named</strong> which you should use to match the provided named route to the widget to be pushed at the top of this child navigation stack.</p>
<p>At the end of the <strong>onGenerateRoute</strong> method, return a <strong>PageRouteBuilder</strong>, provided a <strong>pageBuilder</strong> callback, which returns the widget to be displayed onto the stack, as well as a <strong>transitionDuration</strong>, in case you want to provide a duration - in our case, we set a <strong>Duration</strong> to zero so no transition occurs.</p>
<p>Below the whole code that should go inside the <strong>onGenerateRoute</strong> (we&#39;ll implement each route&#39;s corresponding page individually later on):</p>
<p class="image-container"><img alt="Landing Page" src="img/20f8137f2cbefa5a.png"></p>
<p>Time to kick the tires on this nested navigation!</p>
<h2 is-upgraded>Pushing named routes onto the DonutShopMain child navigation stack</h2>
<p>We said earlier that the <strong>DonutBottomBar</strong> widget, upon the user tapping on one of the items, it will push the corresponding named route. Let&#39;s leverage the existing functionality of the <strong>DonutBottomBar</strong> widget that calls the <strong>setTabSelection</strong> method on the <strong>DonutBottomBarSelectionService</strong> and use the same <strong>tabSelection</strong> as the name of the named route to be pushed onto the child navigation stack, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/2efe77d64491c2f1.png"></p>
<p>With this, we trigger a change in the child navigation stack in the <strong>DonutShopMain</strong> page (via the <strong><em>Utils.mainListNav.currentState!.pushReplacementNamed</em></strong> using the same tab selection) while at the same time preserving the tab selection and triggering a rebuild on the <strong>Consumer</strong> widget. One single line of code change, while no changes on the bottom bar widget. See it in action!</p>
<p class="image-container"><img alt="Landing Page" src="img/b8b4f2bf1241b121.gif"></p>
<p>Notice how the pages get swapped as the user taps on the corresponding bottom bar item.</p>
<p>With the nested navigation in place, we are free to flesh out each of the child pages in the main landing page: the <strong>DonutMainPage</strong>, <strong>DonutFavoritesPage</strong> and the <strong>DonutShoppingCartPage</strong>.</p>
<p>Let&#39;s proceed!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Dissecting the Donut Main Page" duration="0">
        <p class="image-container"><img alt="Landing Page" src="img/8337536bf0c19884.png"></p>
<p>Now we can concentrate on each of the individual child pages that get displayed within the <strong>Navigator</strong> widget inside our <strong>DonutShopMain</strong> landing page. This time the focus is on the <strong>DonutMainPage</strong>.</p>
<p>This page will be comprised of 3 widgets:</p>
<ul>
<li><strong>DonutPager</strong>: a series of images displayed using a pagination scheme, thanks to the help of a <strong>PageView</strong> widget. We will also introduce a way to show page view indicator (the little dots underneath the <strong>PageView</strong> that show how many pages and which is the current one). We&#39;ll create a custom widget for that as well caled <strong>PageViewIndicator</strong>.</li>
<li><strong>DonutFilterBar</strong>: we&#39;ll decouple the ability to trigger the filtering of the list of donuts and move it to a separate component. It will persist its own state and maintain the selected filter.</li>
<li><strong>DonutList</strong>: a scrollable list containing our products (in our case, donuts!) which will display each item in a custom card item (<strong>DonutCard</strong>). Tapping on one of these cards will launch a details view (more on this later in this series).</li>
</ul>
<h2 is-upgraded>Set Up The Layout for the DonutMainPage</h2>
<p>We&#39;ll get some things out of the way first by setting up the layout of the <strong>DonutMainPage</strong> child page widget.</p>
<p>Start by creating a custom widget class called <strong>DonutMainPage</strong> that extends <strong>StatelessWidget</strong>. Override its <strong>build</strong> method as customary and return a <strong>Column</strong> with empty children array as default. As shown above, our child widgets will be laid out vertically:</p>
<p class="image-container"><img alt="Landing Page" src="img/42c6f55f1c675ee5.png"></p>
<p>Then, go to the <strong>Navigator</strong> widget in the <strong>DonutShopMain</strong> page, and in the <strong>onGenerateRoute</strong> callback, find the <strong>switch</strong> case that matches the <strong>/main</strong> named route; replace the placeholder <strong>Center</strong> widget by our newly created <strong>DonutMainPage</strong> custom child page widget, as such:</p>
<p class="image-container"><img alt="Landing Page" src="img/7b75f397b17914eb.png"></p>
<p>With that hooked up, we are ready to expand and define this child page further. Click <strong>Next</strong> to proceed.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Donut Main Page: Donut Pager" duration="0">
        <p>Let&#39;s start with the <strong>DonutPager</strong>. The following image is a schematic view of what we&#39;ll be tackling:</p>
<p class="image-container"><img alt="Landing Page" src="img/380ddaf8e2d3102d.png"></p>
<p>Proceed to create a custom widget called <strong>DonutPager</strong>, this time we&#39;ll make it straight into a <strong>StatefulWidget</strong> since there will be some internal state to be maintained, also we will be using the <strong>PageView</strong> widget, which requires a <strong>PageController</strong> that needs to clean up its resources afterwards.</p>
<aside class="special"><p>Recall that <strong>StatefulWidget</strong>-based widgets require the 2-class approach: the <strong>StatefulWidget</strong> class and a <strong>State</strong> class.</p>
</aside>
<p class="image-container"><img alt="Landing Page" src="img/7d2dfdc1e349a1de.png"></p>
<h2 is-upgraded>Create a PODO model to feed mock data into the DonutPager widget</h2>
<p>In order to feed the images that make up our <strong>DonutPager</strong> widget, we pull them from a remote location. I want to package them nicely in a single object, for which I&#39;ll create a small PODO (Plain Ol&#39; Dart Model) class called <strong>DonutPage</strong>, which will have two properties:</p>
<ul>
<li>imgUrl: the URL of the background image of each page</li>
<li>logoImgUrl: the URL of the small image that shows on top of each background image:</li>
</ul>
<p class="image-container"><img alt="Landing Page" src="img/6b6d7ea8c732539d.png"></p>
<p>With that out of the way, let&#39;s focus our attention back to our <strong>DonutPager</strong>. Let&#39;s create a collection of <strong>DonutPage</strong> objects inside our <strong>DonutPagerState</strong> widget to mock the retrieval of several images to display on our page view.</p>
<p class="image-container"><img alt="Landing Page" src="img/ee6e8e8c85d6259a.png"></p>
<p>Create two more properties:</p>
<ul>
<li>currentPage: type <strong>int</strong>, which will hold the index of the current page being displayed - we&#39;ll use this to display the page indicator later.</li>
<li>controller: type <a href="https://api.flutter.dev/flutter/widgets/PageController-class.html" target="_blank"><strong>PageController</strong></a>. Every <a href="https://api.flutter.dev/flutter/widgets/PageView-class.html" target="_blank"><strong>PageView</strong></a> requires one if you want to manipulate which page is visible at any given time.</li>
</ul>
<p class="image-container"><img alt="Landing Page" src="img/e6b9aebd7f8fd102.png"></p>
<p>Override the <strong>initState</strong> method and initialize the <strong>controller</strong> instance, setting its <strong>initialState</strong> property to zero:</p>
<p class="image-container"><img alt="Landing Page" src="img/fb6f846f99b4d3a8.png"></p>
<aside class="warning"><p>Don&#39;t forget to always dispose your controllers after using them - do it now before you forget! Override the <strong>dispose</strong> method and call <strong>dispose</strong> on your <strong>PageController</strong> instance:</p>
</aside>
<p class="image-container"><img alt="Landing Page" src="img/750ca17338f2ca0d.png"></p>
<p>Now let&#39;s focus our attention inside the <strong>DonutPager</strong>&#39;s <strong>build</strong> method, and let&#39;s build its structure.</p>
<p>Replace the placeholder <strong>Container</strong> widget by a <strong>SizedBox</strong> widget, with a fixed height of 350px. We want to constrain the height of this widget to a fixed dimension. Add a <strong>Column</strong> widget as its child with an empty children array by default:</p>
<p class="image-container"><img alt="Landing Page" src="img/a0894b95521b1b8d.png"></p>
<p>Inside of this <strong>Column</strong> widget is where we want to place the <strong>PageView</strong> widget and later on our custom <strong>PageViewIndicator</strong> widget; we want the <strong>PageView</strong> to occupy most of the <strong>Column</strong>&#39;s real estate, so let&#39;s start by an <strong>Expanded</strong> widget, which will serve as the <strong>PageView</strong>&#39;s wrapper / parent, then add the <strong>PageView</strong> widget as its child:</p>
<p class="image-container"><img alt="Landing Page" src="img/5eb98297f3e97af0.png"></p>
<p>Let&#39;s set some properties on the <strong>PageView</strong> widget:</p>
<ul>
<li>scrollDirection: we want to scroll left and right, so set it to <strong>Axis.horizontal</strong>.</li>
<li>pageSnapping: we want the snapping effect as users scroll, so set it to <strong>true</strong>.</li>
<li>controller: the <strong>PageController</strong> we instantiated earlier, associated to this <strong>PageView</strong>. We&#39;ll control the <strong>PageView</strong> via this controller.</li>
</ul>
<p class="image-container"><img alt="Landing Page" src="img/de1725ac4ee5101b.png"></p>
<p>Time to load the children on this <strong>PageView</strong> widget! We&#39;ll use the <strong>PageView</strong>&#39;s <strong>children</strong> property to feed a list of <strong>DonutPage</strong> objects (which we&#39;ve conveniently created and set up as a <strong>List</strong> of <strong>DonutPage</strong> objects a few steps back).</p>
<p>We&#39;ll conveniently use the <strong>List.generate</strong> factory method with this list to generate widgets on the fly based on how many <strong>DonutPage</strong> objects we have, and feed the data into custom-created widgets containing the image information. To the <strong>List.generate</strong> method, pass the amount of pages available (*<strong>pages.lenght</strong>) and a callback which we&#39;ll use to tap into each item in the iteration, and in turn build each page in the <strong>PageView</strong>, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/130b36aa401e1626.png"></p>
<h2 is-upgraded>Build the structure of each PageView page</h2>
<p>Now let&#39;s focus our attention on the <strong>List.generate</strong>&#39;s callback method. This method receives an <strong>index</strong>, which represents the current item in the iteration, with which we&#39;ll pull the corresponding <strong>DonutPage</strong> object from the list of pages to build the page, as such:</p>
<p class="image-container"><img alt="Landing Page" src="img/790cc6bdf93653eb.png"></p>
<p>Let&#39;s start adding some properties to this <strong>Container</strong> widget:</p>
<ul>
<li>alignment: set it to <strong>Alignment.bottomLeft</strong></li>
<li>margin: 20px all around</li>
<li>padding: 30px all inside</li>
</ul>
<p class="image-container"><img alt="Landing Page" src="img/fc8f3a5e29b4b2b.png"></p>
<p>We&#39;ll use the <strong>Container</strong> widget as a canvas to paint the promo images as a background image, as well as add roundness to the <strong>Container</strong> and some shadow effects to give it some depth. To accomplish all this this we&#39;ll use the <strong>decoration</strong> property of <strong>Container</strong>, which we&#39;ll facilitate all these features. We&#39;ll set the following properties of the <strong>decoration</strong>, type <strong>BoxDecoration</strong>:</p>
<ul>
<li>borderRadius: 30px of radius</li>
<li>boxShadow: color black, with 20px opacity</li>
<li>blurRadius: 10px of blur</li>
<li>offset: We want the shadow to be slightly off on the y-axis, so we&#39;ll use **Offset(0.0, 5.0)</li>
<li>image: set the <strong>image</strong> property to a <strong>DecorationImage</strong>, which allows you to set it as a background to the <strong>Container</strong>; pull the image from the current model (via <strong>currentPage.imgUrl!</strong>) and set it as a <strong>NetworkImage</strong>, with a fit of <strong>BoxFit.cover</strong> so it covers the <strong>Container</strong> while maintaining the aspect ratio.</li>
</ul>
<p>After setting the <strong>decoration</strong> properties, our <strong>Container</strong> code should look like this afterwards:</p>
<p class="image-container"><img alt="Landing Page" src="img/15d39443cbf68253.png"></p>
<p>Let&#39;s test what we&#39;ve built so far.</p>
<p>Back on our <strong>DonutMainPage</strong>, add our newly created <strong>DonutPager</strong> as the first child of the <strong>Column</strong> widget in here, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/e903c0f8148579d1.png"></p>
<p>Running what we have so far on DartPad, and our preview panel should show the following:</p>
<p class="image-container"><img alt="Landing Page" src="img/75dbfd567b667541.png"></p>
<p>Nice, our <strong>DonutPager</strong> widget is in place. The last touch is to add the little image logo right on top of the <strong>Container</strong>&#39;s background, which is as simple as adding it as a child of that same <strong>Container</strong>. Go back to the <strong>Container</strong> being generated as each <strong>PageView</strong> page, then pull the logo image out of the <strong>currentPage</strong> model&#39;s <strong>logoImgUrl</strong> property, and set it to an <strong>Image.network</strong> widget, with a 120px width, as shown below:</p>
<p class="image-container"><img alt="Landing Page" src="img/20ebed3ec11063a9.png"></p>
<p>Taking it for a spin once again, and we should see the logo image showing on top of the background image. Play with swiping left and right, and testing the snapping functionality. Sweet!</p>
<p class="image-container"><img alt="Landing Page" src="img/8043890492487f96.gif"></p>
<p>Let&#39;s keep moving!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Donut Main Page: PageViewIndicator" duration="0">
        <p>Let&#39;s add a nice touch to this <strong>DonutPager</strong> - a way for users to see how many pages they will be viewing, and a way to let them know how far along they are on the list by using some circular indicators. We&#39;ll encapsulate this functionality in a very convenient widget called <strong>PageViewIndicator</strong>.</p>
<p>Check out the schematics of this widget below:</p>
<p class="image-container"><img alt="Landing Page" src="img/c52cfe58d6e2f581.png"></p>
<p>Let&#39;s start by creating a new custom widget class called <strong>PageViewIndicator</strong> that extends <strong>StatelessWidget</strong>. Override its <strong>build</strong> method and return a <strong>Row</strong> widget with an empty children array by default:</p>
<p class="image-container"><img alt="Landing Page" src="img/cb229d475d4ff4b6.png"></p>
<p>Next, we&#39;ll create 3 convenient properties:</p>
<ul>
<li>controller: we will leverage the <strong>PageView</strong>&#39;s <strong>PageController</strong> so we can control the <strong>PageView</strong> from inside this widget (i.e. move the pages, etc.).</li>
<li>numberOfPages: we need how many pages there are so we can render the right amount of circle indicators.</li>
<li>currentPage: we need the index of what the current page is so we can illustrate it accordingly (i.e. set a color to the indicator that matches the current page).</li>
</ul>
<p>Pass the values via this widget&#39;s constructor, and your code should look as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/b0cfb91957bfa65e.png"></p>
<h2 is-upgraded>Build the Structure of the PageViewIndicator</h2>
<p>Let&#39;s focus now on the <strong>build</strong> method of this widget. We want our circular indicators to be centered in the row, so let&#39;s set its <strong>mainAxisAlignment</strong> property to <strong>center</strong>.</p>
<p class="image-container"><img alt="Landing Page" src="img/feffd661a5b30524.png"></p>
<p>To populate each circular indicator based on the number of pages available, let&#39;s populate the <strong>Row</strong>&#39;s <strong>children</strong> property through the <strong>List.generate</strong> factory method, passing the <strong>numberOfPages</strong> as the length of items to iterate on, and the callback that will spit out each indicator in turn, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/9b2bf704217c6e3c.png"></p>
<p>Now let&#39;s give more definition to the <strong>Container</strong> that will represent each page indicator.</p>
<p>Let&#39;s start adding some properties to give this <strong>Container</strong> the circular shape and color we want. Start by adding the following:</p>
<ul>
<li>width and height: 15px</li>
<li>margin: 10px all around</li>
<li>decoration: we&#39;ll use a <strong>BoxDecoration</strong> to apply the following:  <ul>
<li>borderRadius: 10px of radius to make it look circular</li>
<li>color: we&#39;ll set the color based on what the index of the value of the <strong>currentPage</strong> is; we&#39;ll leverage the <strong>index</strong> parameter supplied to this callback.</li>
</ul>
</li>
</ul>
<p>Your code should look as follows afterwards:</p>
<p class="image-container"><img alt="Landing Page" src="img/f5fc65e71527ab56.png"></p>
<p>Let&#39;s start plugging this widget in place.</p>
<p>Back on our <strong>DonutPagerState</strong> widget, inside the <strong>build</strong> method, locate the <strong>Expanded</strong> widget that is wrapping our <strong>PageView</strong> widget. Right underneath it, add our newly created <strong>PageViewIndicator</strong> widget. Pass the required values, as illustrated below:</p>
<p class="image-container"><img alt="Landing Page" src="img/e3b467eca751a8ce.png"></p>
<p>Running this on DartPad, and you should see the page indicator circles showing up! Hooray!!!</p>
<p class="image-container"><img alt="Landing Page" src="img/3cd4281246206ce5.png"></p>
<p>Wait - no so fast. They are showing alright, but when you slide left and right, the indicators don&#39;t show what the current page - is as if this control is static. We want it so that when we swipe on the <strong>PageView</strong> widget, the <strong>PageViewIndicator</strong> also reflects the index of which page is currently showing.</p>
<p>For this, you need to tap into the <strong>PageView</strong> widget&#39;s <strong>onPageChanged</strong> event. This event gets triggered every time a user swipes on the specified direction, thus triggering a change on the page. This gets assigned a callback, which supplies a parameter of type <strong>int</strong> that represents the current page being shown.</p>
<p>What we&#39;ll do is tap into this callback, capture the index of the current page being displayed, and trigger a widget rebuild so the <strong>PageViewIndicator</strong> rebuilds as well, reflecting the correct current page being displayed.</p>
<p>In the <strong>PageView</strong> widget, hook up a callback to the <strong>onPageChanged</strong> event, and inside this callback, trigger a rebuild using the <strong>setState</strong> method available on this <strong>State</strong> class. Inside of this method, then set the <strong>currentPage</strong> property using the <strong>page</strong> property supplied by the callback, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/effcd2ba14156a9e.png"></p>
<p>Now with these latest changes, after swiping left and right, you should see the indicator changing! Now we are talking!</p>
<p class="image-container"><img alt="Landing Page" src="img/b68ffcec90e28614.gif"></p>
<h2 is-upgraded>BONUS #1: Add More Interactivity to the PageViewIndicator</h2>
<p>Cool that this widget shows the currently displayed page from the <strong>PageView</strong>. What if I want to use those same indicators to take me to the corresponding page I want to see? So simple - let me show you.</p>
<p>Back in your <strong>PageViewIndicator</strong> widget, wrap the <strong>Container</strong> that represents the indicator inside a <strong>GestureDetector</strong>, since we want to make this <strong>Container</strong> tappable.</p>
<p class="image-container"><img alt="Landing Page" src="img/1ab69db4bed9d7b4.png"></p>
<p>We will leverage the <strong>GestureDetector</strong>&#39;s <strong>onTap</strong> event, and inside it, use the <strong>PageController</strong>&#39;s <strong>animateToPage</strong> method, to which you&#39;ll pass the index of the page indicator (which will be the same as the page index), the <strong>duration</strong> of the page sliding effect, and the <strong>curve</strong> of the animation.</p>
<p>At the end your code should look like below:</p>
<p class="image-container"><img alt="Landing Page" src="img/10406a2a396a7b3e.png"></p>
<h2 is-upgraded>BONUS #2: Animate the Coloring of the Indicators in the PageViewIndicator</h2>
<p>We can also add some animation to the color changing effect in the <strong>PageViewIndicator</strong> individual indicators. A nice-to-have, that kind of smoothens out the animation. Let&#39;s do it real quick.</p>
<p>Back to that same <strong>Container</strong> that represents each indicator widget, replace the <strong>Container</strong> by an <strong>AnimatedContainer</strong> widget. The <strong>AnimatedContainer</strong> is one of those explicit animation widgets available in the library that does all the heavy lifting for you when it comes to animate any of the properties available on a <strong>Container</strong>. In our case, we want to animate the <strong>color</strong> property, which is the only thing that changes between widget rebuilds.</p>
<p>Replace <strong>Container</strong> by <strong>AnimatedContainer</strong>, and supply two additional properties to get it going:</p>
<ul>
<li>curve: the animation curve (i.e. Curves.easeInOut)</li>
</ul>
<p>After applying the <strong>AnimatedContainer</strong>, your code should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/d0e9cfbc5ef6730e.png"></p>
<p>Run it once again and you&#39;ll notice the color animation, which looks much smoother and slicker! Kudos to you!</p>
<p class="image-container"><img alt="Landing Page" src="img/a67ed5cc69e2c208.gif"></p>
<p>And that about wraps up the <strong>DonutPager</strong> which included the <strong>PageViewIndicator</strong>. Click next to proceed to the next section.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Donut Main Page: Donut Filter Bar" duration="0">
        <p class="image-container"><img alt="Landing Page" src="img/6070df51a4eeb1c2.gif"></p>
<p>The <strong>DonutFilterBar</strong> is a widget that handles the filtering of the list of donuts by their types (classic, sprinkled and stuffed). I made it custom so as to continue introducing State Management concepts as well as bringing more interactivity to your apps by introducing both <a href="https://flutter.dev/docs/codelabs/explicit-animations" target="_blank">explicit</a> and <a href="https://flutter.dev/docs/codelabs/implicit-animations" target="_blank">implicit</a> animations.</p>
<p>The following schematic view shows how we&#39;ll be tackling it:</p>
<p class="image-container"><img alt="Landing Page" src="img/9e49f404d7a4d165.png"></p>
<p>Each filter bar item will perform the filtering of the list of donuts below, as well as change the color of the currently selected one, and perform an animation by showing a sliding bar that runs across the filter bar and lands on the currently selected bar item.</p>
<p>Let&#39;s proceed!</p>
<h2 is-upgraded>Creating the core DonutFilterBar widget</h2>
<p>First things first - let&#39;s create the custom widget that will hold the filter bar, so create a class called <strong>DonutFilterBar</strong> and make it extend <strong>StatelessWidget</strong>:</p>
<p class="image-container"><img alt="Landing Page" src="img/d12382e9ce78e237.png"></p>
<p>Let&#39;s give a pause on building the structure of this widget to give way to building the mocked data and services required to hydrate this widget.</p>
<h2 is-upgraded>Creating the model that represents each Filter Bar Item</h2>
<p>Let&#39;s create another useful PODO (Plain Ol&#39; Dart Object) that will hold the data for each of the filter bar items. Let&#39;s call it <strong>DonutFilterBarItem</strong>. We are only interested in knowing the label to display, and the id to uniquely identify the currently selected filter bar item.</p>
<p class="image-container"><img alt="Landing Page" src="img/a2dc6337fbf5d287.png"></p>
<h2 is-upgraded>Create a Provider Service To Hold Donut Information</h2>
<p>We need to create a provider service to hold all the logic of persisting the currently selected filter, the list of filters available, and later on we&#39;ll use it to perform the actual filter and hold the data of our available products.</p>
<p>Let&#39;s start by creating a provider service class called <strong>DonutService</strong>. This class will also extends <strong>ChangeNotifier</strong> since this will perform operations that may trigger widget rebuilds:</p>
<p class="image-container"><img alt="Landing Page" src="img/e7b08812f4b95cc9.png"></p>
<aside class="special"><p><strong>IMPORTANT</strong>: since we want to make this service globally available throughout our app, let&#39;s inject it at the root of the app as part of the <strong>providers</strong> collection of the existing <strong>MultiProvider</strong> widget up top (that way we don&#39;t forget it later!), as follows:</p>
</aside>
<p class="image-container"><img alt="Landing Page" src="img/4b332ef0c6083a78.png"></p>
<p>In our newly created service, create a mocked data collection representing the three categories of donuts, against which our users should be able to filter their donuts on. Make it a <strong>List</strong> of type <strong>DonutFilterBarItem</strong> and populate it accordingly:</p>
<p class="image-container"><img alt="Landing Page" src="img/240da9643e68d433.png"></p>
<p>Proceed to create a property called <strong>selectedDonutType</strong>, type <strong>string</strong>; in the service&#39;s constructor, set an initial value to be the first filter bar item id (*<strong>classic</strong>) as a default value. This property will hold the value of the selected filter bar item at any given point and we have a starting point for what to render the default selection with:</p>
<p class="image-container"><img alt="Landing Page" src="img/7206ea7311c73673.png"></p>
<p>In this same service, let&#39;s create a convenient method to call when the user taps on each filter bar item to perform the actual filtering. We will only hold the selected filter bar item for now - later we&#39;ll perform the actual filtering. Subsequently, make a call to <strong>notifyListeners</strong> (provided by inheriting from <strong>ChangeNotifier</strong>) to trigger a widget rebuild in the event that the <strong>selectedDonutType</strong> has changed:</p>
<p class="image-container"><img alt="Landing Page" src="img/cb12176df9292f21.png"></p>
<p>With our data mocked up and our provider service ready to be consumed, let&#39;s proceed and wrap up the <strong>DonutFilterBar</strong> widget structure.</p>
<h2 is-upgraded>Creating the DonutFilterBar widget structure</h2>
<p>In the <strong>DonutFilterBar</strong> widget, replace the placeholder <strong>Container</strong> widget by a more specialized <strong>Padding</strong> widget - we only need to apply padding here, so there&#39;s no need for a full-blown <strong>Container</strong>. Apply padding all inside of 20px:</p>
<p class="image-container"><img alt="Landing Page" src="img/1d0c0a12d5132333.png"></p>
<p>Since we&#39;ll be listening to changes on the currently selected filter bar item, which is being held in the <strong>DonutService</strong> provider service, let&#39;s go right ahead and create a <strong>Consumer</strong> widget. Recall that a <strong>Consumer</strong> widget will trigger its <strong>builder</strong> method when it calls <strong>notifyListeners</strong> internally - in our case, upon users tapping on the available filtering options. Make the <strong>Consumer</strong> widget a direct child of the <strong>Padding</strong> widget:</p>
<p class="image-container"><img alt="Landing Page" src="img/42ad7fe51cc7919e.png"></p>
<p>We must return something out of the <strong>Consumer</strong>&#39;s <strong>builder</strong> method, therefore if we go by the schematic graphic above, we must start by creating a <strong>Column</strong> widget:</p>
<p class="image-container"><img alt="Landing Page" src="img/2791775789565ff2.png"></p>
<p>This <strong>Column</strong> will hold the <strong>Row</strong> of filters, some spacing and the sliding bar.</p>
<p>Let&#39;s start from the top and add a <strong>Row</strong> widget, in which its items will be spaced out, hence setting its <strong>mainAxisAlignment</strong> to <strong>spaceAround</strong>:</p>
<p class="image-container"><img alt="Landing Page" src="img/d11169995c23b9f6.png"></p>
<p>This <strong>Row</strong> widget will hold the filter bar items, based on the <strong>filterBarItems</strong> collection of <strong>DonutFilterBarItem</strong> objects we mocked up earlier in the provided <strong>DonutService</strong>. Populate the <strong>children</strong> property of the <strong>Row</strong> by using the convenient factory method <strong>List.generate</strong>, feeding into it the <strong>filterBarItems</strong> collection and a callback that will generate each filter bar item accordingly:</p>
<p class="image-container"><img alt="Landing Page" src="img/d4746211665c02e2.png"></p>
<p>Inside the <strong>List.generate</strong> callback, extract the corresponding <strong>DonutFilterBarItem</strong> out of the provided service <strong>donutService</strong> and its <strong>filterBarItems</strong> property, using the supplied <strong>index</strong> value through the callback, and holding it in a property called <strong>item</strong>:</p>
<p class="image-container"><img alt="Landing Page" src="img/3d0cda007ce544bd.png"></p>
<p>Using each <strong>DonutFilterBarItem</strong> item, construct a <strong>Container</strong> widget that wraps a <strong>Text</strong> widget inside, with the correct <strong>item.label</strong> value as well as the corresponding color style, based on whether the currently selected filter bar item (stored in <strong>donutService.selectedDonutType</strong>) matches the <strong>item.id</strong>, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/93e3dc01c0757769.png"></p>
<p>Let&#39;s take what we&#39;ve build so far for a spin.</p>
<p>Plug in this widget into its final destination, by adding it right below the <strong>DonutPager</strong> widget inside the <strong>DonutMainPage</strong> child page widget:</p>
<p class="image-container"><img alt="Landing Page" src="img/cabf7a0ea2362b69.png"></p>
<p>Running this on DartPad to see what is looking like, should yield the following result:</p>
<p class="image-container"><img alt="Landing Page" src="img/a906da80c4385c32.png"></p>
<p>At least you can see the currently selected default item (<strong><em>Classic</em></strong>) but there&#39;s no interactivity and no way to change the current selection. In the next step, we&#39;ll add more interactivity to it.</p>
<h2 is-upgraded>Add Interactivity to DonutFilterBar Upon Bar Item Tapping</h2>
<p>Let&#39;s make them clickable now. Back to the <strong>DonutFilterBar</strong>, inside the <strong>List.generate</strong> callback of the <strong>Row</strong> widget, wrap each <strong>Container</strong> widget inside a <strong>GestureDetector</strong> widget to leverage its tapping capabilities:</p>
<p class="image-container"><img alt="Landing Page" src="img/314faf29a95e3f61.png"></p>
<p>Inside the <strong>GestureDetector</strong>&#39;s <strong>onTap</strong> event, invoke the <strong>donutService.filteredDonutsByType</strong> method, passing the corresponding item&#39;s <strong>id</strong> upon the user tapping on the filter bar item. This will persist the currently selected filter bar item, as well as trigger the parent <strong>Consumer</strong> widget, kicking off a rebuild, which eventually updates the selected filter bar item:</p>
<p class="image-container"><img alt="Landing Page" src="img/7283e50c220e6846.png"></p>
<p>Running it again, and tapping on the different filter bar items available, should yield the following result:</p>
<p class="image-container"><img alt="Landing Page" src="img/db6771ddaaa8599e.gif"></p>
<p>Let&#39;s add yet more interactivity by adding the sliding bar below this <strong>Row</strong> widget.</p>
<h2 is-upgraded>Adding Sliding Bar below Filter Bar Item Row</h2>
<p>The sliding bar effect under the <strong>Row</strong> widget is nothing fancy - is nothing more than a <strong>Container</strong> widget that animates its alignment between 3 available positions (left, center and right) over a short period of time in a smooth fashion. Let me show you how I did it.</p>
<p>Back in our <strong>DonutFilterBar</strong> widget, first add some spacing between the <strong>Row</strong> of filter bar item widgets and our upcoming sliding bar. Make it a <strong>SizedBox</strong> with a 10px height:</p>
<p class="image-container"><img alt="Landing Page" src="img/fe45dcf3690bfd36.png"></p>
<p>Right under this spacing widget, add a <strong>Stack</strong> widget.</p>
<p class="image-container"><img alt="Landing Page" src="img/747434368d08eb2f.png"></p>
<p>We&#39;ll use a <strong>Stack</strong> which will occupy the whole width of the screen and will function as some sort of &#34;rail&#34; on which our <strong>Container</strong> widget will slide from left to right, aided by an <strong>AnimatedAlign</strong> widget, which will change its value from 3 possible options based on the selected filter bar item: left (<strong><em>Classic</em></strong>), center (<strong><em>Sprinkled</em></strong>) and right (<strong><em>Stuffed</em></strong>). Let&#39;s create a method that will handle this logic.</p>
<p>Create a local method to this widget called <strong>alignmentBasedOnTap</strong> that takes as a parameter the <strong>id</strong> of the selected filter bar item, and will perform the logic of returning the corresponding alignment based on the provided filter bar item id:</p>
<p class="image-container"><img alt="Landing Page" src="img/7b513ad229b4a310.png"></p>
<p>Back on the <strong>Stack</strong>, add as its only child inside the <strong>children</strong> collection, an <strong>AnimatedAlign</strong> widget, with the following properties:</p>
<ul>
<li>curve: the curve of the animation (Curves.easeInOut)</li>
<li>alignment: we&#39;ll set the alignment based on the result of executing the logic inside the method <strong>alignmentBasedOnTap</strong> provided the currently selected donut type (held in <strong>donutService.selectedDonutType</strong>)</li>
</ul>
<p>Your code should look like this so far:</p>
<p class="image-container"><img alt="Landing Page" src="img/32623f17d05065b0.png"></p>
<p>Now the only thing missing is the <strong>Container</strong> widget that will represent the bar that will simulate a sliding effect. Add as a child of the <strong>AnimatedAlign</strong> widget a <strong>Container</strong> widget with the following specs:</p>
<ul>
<li>width: a third of the screen&#39;s width - 20px (to account for the outer margins) using the <strong>MediaQuery.of(context).size.width</strong> to pull the width of the screen from the system. More on <strong>MediaQuery </strong><a href="https://api.flutter.dev/flutter/widgets/MediaQuery-class.html" target="_blank">here</a>.</li>
<li>height: 5px heigh</li>
<li>decoration: using a <strong>BoxDecoration</strong> object to add the following:  <ul>
<li>color: Utils.mainColor</li>
<li>borderRadius: rounded edges of 20px on all corners</li>
</ul>
</li>
</ul>
<aside class="special"><p>Using the <a href="https://api.flutter.dev/flutter/widgets/MediaQuery-class.html" target="_blank"><strong>MediaQuery</strong></a> class in Flutter allows you to achieve responsiveness in your apps and build very fluid interfaces with ease.</p>
</aside>
<p>The whole <strong>AnimatedAlign</strong> widget, including its <strong>Container</strong> widget should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/7eff234d193f84eb.png"></p>
<p>Running it one more time on DartPad in order to test the sliding effect, should show you this on the preview panel:</p>
<p class="image-container"><img alt="Landing Page" src="img/56ca95b9d090849b.gif"></p>
<p>And that takes care of the <strong>DonutFilterBar</strong> widget in its entirety. You should feel proud of what you&#39;ve accomplished and all we&#39;ve learned in terms of widget composition, animations and state management!</p>
<p>Let&#39;s move on to the next and last widget of the <strong>DonutMainPage</strong> - the <strong>DonutList</strong> widget!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Donut Main Page: Donut List Widget" duration="0">
        <p>Let&#39;s check out the schematic view of the <strong>DonutList</strong> widget we&#39;ll be building in this section:</p>
<p class="image-container"><img alt="Landing Page" src="img/d893e908f0942abd.png"></p>
<p>The <strong>DonutList</strong> will consist of an <strong>AnimatedList</strong> widget, which is an animated version of the <strong>ListView</strong>, a scrollable container of child widgets. Each of the child widgets will be a custom <strong>DonutCard</strong> that will display the information of our donut products.</p>
<p>At the end of this codelab, we will hook it up to the <strong>DonutFilterBar</strong> we created earlier so we can filter the list of donuts by the selected filter bar item (between Classic, Sprinkled and Stuff).</p>
<p>Let&#39;s proceed.</p>
<h2 is-upgraded>Set up the data to feed into the DonutList Widget</h2>
<p>Just like we&#39;ve done in the previous widgets, we&#39;ll use some mocked data to hydrate the list of widgets, in our case we need a collection of donut products, each of which may contain the image of the product, name, price and description. Notice where I&#39;m headed? Yes, we will need a PODO object that will encapsulate this data.</p>
<p>Let&#39;s create a model class called <strong>DonutModel</strong>, which will contain the following properties:</p>
<ul>
<li>imgUrl: the image of the donut, hosted on the cloud</li>
<li>name: the name of the product</li>
<li>description: the description of the product</li>
<li>price: the price</li>
<li>type: the type of donut; we&#39;ll use this for the filtering functionality</li>
</ul>
<p>Your model class should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/b678cfdf805217d.png"></p>
<h2 is-upgraded>Prepare mocked data in the Utils class</h2>
<p>I&#39;ve prepared some static mocked data collection representing a list of donut products for use within this app. Feel free to copy / paste the code below anywhere inside the <strong>Utils</strong> class we created earlier:</p>
<pre><code language="language-flutter" class="language-flutter">/* place inside the Utils class */

static List&lt;DonutModel&gt; donuts = [
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic1.png&#39;,
      name: &#39;Strawberry Sprinkled Glazed&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic2.png&#39;,
      name: &#39;Chocolate Glazed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;classic&#39;,
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic3.png&#39;,
      name: &#39;Chocolate Dipped Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic4.png&#39;,
      name: &#39;Cinamon Glazed Glazed&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic5.png&#39;,
      name: &#39;Sugar Glazed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled1.png&#39;,
      name: &#39;Halloween Chocolate Glazed&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled2.png&#39;,
      name: &#39;Party Sprinkled Cream&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled3.png&#39;,
      name: &#39;Chocolate Glazed Sprinkled&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled4.png&#39;,
      name: &#39;Strawbery Glazed Sprinkled&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled5.png&#39;,
      name: &#39;Reese\&#39;s Sprinkled&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 3.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed1.png&#39;,
      name: &#39;Brownie Cream Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed2.png&#39;,
      name: &#39;Jelly Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed3.png&#39;,
      name: &#39;Caramel Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.59,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed4.png&#39;,
      name: &#39;Maple Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed5.png&#39;,
      name: &#39;Glazed Jelly Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.59,
      type: &#39;stuffed&#39;
    )
  ];

</code></pre>
<p>With that out of the way, let&#39;s create our custom <strong>DonutList</strong> widget.</p>
<h2 is-upgraded>Creating the core DonutList widget</h2>
<p>Start by creating a custom widget class called <strong>DonutList</strong>, which inherits from <strong>StatefulWidget</strong> (we will make it <strong>StatefulWidget</strong> from the get-go since later we will introduce implicit animations which require tacking on to the <strong>State</strong>). Right out of the gate, make the corresponding <strong>State</strong> class (which you can call <strong>_DonutListState</strong>) return a <strong>ListView</strong> from its overriden <strong>build</strong> method (let&#39;s start with a <strong>ListView</strong> to get things going, later down the lab we&#39;ll turn it into an <strong>AnimatedList</strong>).</p>
<aside class="special"><p>Recall that <strong>StatefulWidget</strong>-based widgets require the 2-class approach: the <strong>StatefulWidget</strong> class and a <strong>State</strong> class.</p>
</aside>
<p>This should be your code:</p>
<p class="image-container"><img alt="Landing Page" src="img/c2bb4ed1f4e64774.png"></p>
<p>Let&#39;s refactor the default constructor of the <strong>DonutList </strong></p>
<p><strong><em>Stateful</em></strong> widget to take a list of <strong>DonutModel</strong> objects, therefore create the corresponding class member to hold its value, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/26fb92f11b539d25.png"></p>
<p>Let&#39;s continue. In the <strong>_DonutListState</strong> class, where the <strong>build</strong> method resides, replace the existing <strong>ListView</strong> by a <strong>ListView.builder</strong>; this is because the <strong>ListView.builder</strong> factory method resembles more the <strong>AnimatedList</strong> constructor for when we build the animated version of the list. Add the following properties to the <strong>ListView.builder</strong>:</p>
<ul>
<li>scrollDirection: we want it to scroll horizontal, so set it to **Axis.horizontal</li>
<li>itemCount: the number of items in the collection; let&#39;s set it to the length of the <strong>widget.donuts</strong> collection of <strong>DonutModel</strong> items; we&#39;ll provide this later via the constructor</li>
<li>itemBuilder: a callback that spits out widgets based on the provided <strong>context</strong> and the index corresponding to the current iteration.</li>
</ul>
<p>Your code should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/5ecabb3bc128aa76.png"></p>
<p>Let&#39;s add something to the <strong>itemBuilder</strong> callback so it stops barking (see the red squiggly line!). Let&#39;s come back to this method, and go ahead and build out the structure of each of the donut cards.</p>
<h2 is-upgraded>Creating the DonutCard widget</h2>
<p>Inside of the <strong>ListView</strong> widget (and eventually the <strong>AnimatedList</strong> widget), we would like to display each donut as a separate widget, in a card-looking fashion that we&#39;ll custom create. Check out this quick schematic view of our card.</p>
<p class="image-container"><img alt="Landing Page" src="img/33fd3d110bb9ebd.png"></p>
<p>Notice the overlapping nature of some of its parts, to give it a unique effect. Users will eventually be able to tap on this card, which will reveal more details about this product by performing a navigation action. More on this on the next lab. Let&#39;s proceed with our custom card.</p>
<h2 is-upgraded>Creating the core DonutCard widget</h2>
<p>Let&#39;s start by creating another custom widget class called <strong>DonutCard</strong> that extends <strong>StatelessWidget</strong>.</p>
<p>While overriding its <strong>build</strong> method, return a <strong>Stack</strong> widget - this will be the foundation widget of our structure:</p>
<p class="image-container"><img alt="Landing Page" src="img/71a3694d2f01087a.png"></p>
<p>Add an empty children array by default, and make sure that when we lay them out, they are center aligned, using the <strong>Alignment.center</strong> alignment option:</p>
<p class="image-container"><img alt="Landing Page" src="img/b099bc6bcaa29794.png"></p>
<p>Since a <strong>Stack</strong> lays out his children in a layered fashion (bottom-up), let&#39;s lay down the first children, which is a <strong>Container</strong> - the one holding the name and price info.</p>
<p>Add a <strong>Container</strong> inside the <strong>Stack</strong> as its first child, with the following specs:</p>
<ul>
<li>width: 150px width, we want to constrain how wide the card is</li>
<li>alignment: we want the content aligned bottom left</li>
<li>margin: 80px at the top, 10px left and right, 20px bottom</li>
<li>decoration: set up a <strong>BoxDecoration</strong> object with the following:  <ul>
<li>color: white</li>
<li>borderRadius: we want soft round edges - 20px radius should do</li>
<li>boxShadow: we want to give it some depth  <ul>
<li>color: black with .05 opacity</li>
<li>blurRadius: 10px of blur</li>
<li>offset: a bit lower on the y-axis (Offset(0.0, 4.0))</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Your <strong>Container</strong> should look like this afterwards:</p>
<p class="image-container"><img alt="Landing Page" src="img/fe41d0bfded0f360.png"></p>
<p>As the child of this <strong>Container</strong>, add a <strong>Column</strong> widget, with an empty children array to start with. We want our items to be aligned at the bottom of the column, left-aligned - therefore set the <strong>mainAxisAlignment</strong> to <strong>end</strong>, and <strong>crossAxisAlignment</strong> to <strong>start</strong>:</p>
<p class="image-container"><img alt="Landing Page" src="img/e3adb71773b82f1c.png"></p>
<p>We want to display information related to a donut product, so where will we pull this info? Let&#39;s make some changes to this class before proceeding any further.</p>
<p>Add a new property to this <strong>DonutCard</strong> widget called <strong>donutInfo</strong>, type <strong>DonutModel</strong>, and feed it via the constructor. We&#39;ll use this property to feed data into this widget and render the text labels and image, as such:</p>
<p class="image-container"><img alt="Landing Page" src="img/e82dc2d2732fd0f5.png"></p>
<p>Now let&#39;s get back to the structure we were building earlier - the <strong>Column</strong> widget that will hold the text content, so let&#39;s focus on that column for a bit.</p>
<p>Add the first item in the <strong>Column</strong>: a <strong>Text</strong> widget that will display the name of the donut (pulling the data out of the injected <strong>donutInfo</strong> model via the constructor), with the following specs for its <strong>TextStyle</strong>:</p>
<ul>
<li>color: Utils.mainDark</li>
<li>fontWeight: FontWeight.bold</li>
<li>fontSize: 15</li>
</ul>
<p>Your <strong>Text</strong> widget should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/cebb7c1b9713e845.png"></p>
<p>Add some spacing underneath the <strong>Text</strong> widget by adding a <strong>SizedBox</strong> with 10px of height - give it some breathing room:</p>
<p class="image-container"><img alt="Landing Page" src="img/b0330169cbf0c9b3.png"></p>
<p>Now let&#39;s add the little badge to display the price information in. For that, we&#39;ll use a <strong>Container</strong> widget, with the following specs:</p>
<ul>
<li>padding: 10px left and right, 5px top and bottom</li>
<li>decoration: using a BoxDecoration object to set the following values:  <ul>
<li>color: Utils.mainColor</li>
<li>borderRadius: we want soft round edges, with 20px radius</li>
</ul>
</li>
</ul>
<p>Your <strong>Container</strong> should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/30022619843f5db1.png"></p>
<p>We need to display the price information inside this little badge <strong>Container</strong> widget by pulling the value from <strong>donutInfo.price</strong>, so assign a <strong>Text</strong> widget as the sole child of this <strong>Container</strong>, with the following specs:</p>
<ul>
<li>for the <strong>Text</strong> value: use the <strong>donutInfo.price</strong> and the extension method <strong>toStringAsFixed</strong> to format the price information with 2 decimal digits, and adding the dollar sign in front (remember to escape it (â€˜\$&#39;)</li>
<li>for the <strong>TextStyle</strong>:  <ul>
<li>fontSize: 12px</li>
<li>color: Colors.white (for better contrast against the background)</li>
<li>fontWeight: FontWeight.bold</li>
</ul>
</li>
</ul>
<p>Your <strong>Text</strong> widget inside the <strong>Container</strong> should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/2c98bf9caafdbf41.png"></p>
<h2 is-upgraded>Test the DonutCard and DonutList (pt.1)</h2>
<p>We&#39;ve coded a lot - let&#39;s see how things are looking so far. We&#39;ll get back to finalizing the structure, but let&#39;s test what we&#39;ve built up to this point.</p>
<p>Back up to the <strong>_DonutListState</strong> widget, inside the <strong>itemBuilder</strong> callback of the <strong>ListView.builder</strong>, let&#39;s use the <strong>DonutCard</strong> here. First, pull a <strong>DonutModel</strong> object out of the <strong>donuts</strong> list that we&#39;ll be injected via the constructor, using the <strong>index</strong> supplied through the callback. Hold the value in a variable called <strong>currentDonut</strong>:</p>
<p class="image-container"><img alt="Landing Page" src="img/af1753fadd041d27.png"></p>
<p>Now, use this <strong>currentDonut</strong> to churn out <strong>DonutCard</strong> widgets out of this callback. Return a <strong>DonutCard</strong> widget, and pass the <strong>currentDonut</strong> into the constructor, as such:</p>
<p class="image-container"><img alt="Landing Page" src="img/9df2faa9557ec0f3.png"></p>
<p>With that hooked up, let&#39;s go back to the <strong>DonutMainPage</strong> and start putting the <strong>DonutList</strong> in place to test how&#39;s coming out. We&#39;ll even feed it the mocked donuts list straight up (<strong><em>Utils.donuts</em></strong>) just to see it in action. Add the <strong>DonutList</strong> widget right under the <strong>DonutFilterBar</strong>, feeding it the <strong>Utils.donuts</strong> assigning it to the <strong>donuts</strong> argument.</p>
<p>Since we&#39;re adding it to the main <strong>Column</strong> layout of the <strong>DonutMainPage</strong> widget, and we want it to take up most of the real estate in the column, wrap it inside an <strong>Expanded</strong> widget, as such:</p>
<p class="image-container"><img alt="Landing Page" src="img/ca34bb5f26618ccc.png"></p>
<p>Running what we have so far on DartPad, you should be able to see the following:</p>
<p class="image-container"><img alt="Landing Page" src="img/f83f7e8de433345a.png"></p>
<p>Now, let&#39;s finish up the <strong>DonutCard</strong> by adding the missing piece - the donut image. Recall that we added a <strong>Stack</strong> widget in order to achieve that staggered / overlapped effect between the image and the card content below. Let&#39;s do it!</p>
<p>Back to the <strong>DonutCard</strong> widget, locate the <strong>Stack</strong> widget. Right under the existing <strong>Container</strong> widget that holds the text information, we&#39;ll add an <strong>Image</strong> widget, using the <strong>Image.network</strong> option, but to achieve the staggered effect, we&#39;ll wrap the <strong>Image</strong> inside an <strong>Align</strong> widget with a top center alignment. Recall that the <strong>Container</strong> widget has a top margin of 80px in order to force the white space we&#39;ll be devoting to the image. Once the <strong>Align</strong> widget anchors itself to the top center of the <strong>Stack</strong>, it will have that overlapping effect.</p>
<p>Add the <strong>Image</strong> widget using the network option, with 150px in dimension, and a fit of <strong>BoxFit.contain</strong> to make sure it preserves its aspect ratio. Feed the image path by pulling it out of the <strong>donutInfo.imgUrl</strong>. Wrap the image inside an <strong>Align</strong> widget, with a <strong>topCenter</strong> alignment, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/c2cd8c5ff145d18.png"></p>
<p>Re-run the app in DartPad and it should look pretty much done up to this point:</p>
<p class="image-container"><img alt="Landing Page" src="img/e428de6fa38cc757.png"></p>
<p>And if you scroll through all items available, notice we are showing them all - there&#39;s no filtering. Now we should be able to hook up the <strong>DonutFilterBar</strong> filtering functionality with the <strong>DonutList</strong>, so when the user taps on the desired filter bar item, the <strong>DonutList</strong> widget and its list of donuts filters itself to show only the selected item.</p>
<p class="image-container"><img alt="Landing Page" src="img/3d5619e414d66fb3.gif"></p>
<p>Let&#39;s work on that!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Connect the DonutFilterBar with the DonutList: Filtering Functionality" duration="0">
        <p>In order to have the <strong>DonutFilterBar</strong> communicate with the <strong>DonutList</strong> in a decoupled way, we&#39;ll leverage the <strong>DonutService</strong> we created earlier. When the filtering is triggered from the <strong>DonutFilterBar</strong>, the <strong>DonutList</strong> listens to that change and rebuilds itself accordingly, feeding into it the filtered donut list - and the glue between them is the <strong>DonutService</strong>.</p>
<h2 is-upgraded>Refactor the DonutService to pull donut data</h2>
<p>Let&#39;s go to the <strong>DonutService</strong> and start by adding a new property - a <strong>List</strong> of type <strong>DonutModel</strong> called <strong>filteredDonuts</strong> that we&#39;ll use to hold the filtered list of donut products at any given time. Initialize it with an empty array for now:</p>
<p class="image-container"><img alt="Landing Page" src="img/cda13469b973c9da.png"></p>
<p>In the existing method called <strong>filteredDonutsByType</strong>, right after we assigned the <strong>selectedDonutType</strong> with the currently selected filter bar item from the <strong>DonutFilterBar</strong> widget, perform a filter against the existing mocked data in the <strong>Utils.donuts</strong>, and retrieved a filtered list of the donuts that match their type against the <strong>selectedDonutType</strong>; for this, use the existing <strong>type</strong> property from the <strong>DonutModel</strong>, then assign the resulting list to the <strong>filteredDonuts</strong> collection:</p>
<p class="image-container"><img alt="Landing Page" src="img/25ab93cb0f614e72.png"></p>
<p>Notice that we still keep the <strong>notifyListeners</strong> call at the end of this method; this will ensure that when the <strong>DonutList</strong> rebuilds itself when listens to a change in this service. All we&#39;re missing to do is make the <strong>DonutList</strong> widget <strong>listen</strong> for changes occurring on the <strong>DonutService</strong>, and what better way to do it than make it a &#34;consumer&#34; of the <strong>Donutservice</strong>.</p>
<p>Last thing to do is take care of the initial load, since initially the user hasn&#39;t selected anything!. For this, we will execute the <strong>filteredDonutsByType</strong> in the <strong>DonutService</strong>&#39;s constructor, using the default value assigned to <strong>selectedDonutType</strong> from the first item in the <strong>filterBarItems</strong> collection, and assigning it to the <strong>filteredDonuts</strong> collection, also as a default initial filtered collection, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/5e0d3d8d24c88dd8.png"></p>
<p>Back in the <strong>DonutMainPage</strong>, locate the <strong>DonutList</strong> widget, wrapped inside an <strong>Expanded</strong> widget. All we need to do is wrap this widget into a <strong>Consumer</strong> widget that listens to the <strong>DonutService</strong>, and feeds the updated <strong>filteredDonuts</strong> into the <strong>DonutList</strong> upon rebuilding, accurately showing the shorten list of donuts, matching what the user selected, as such:</p>
<p class="image-container"><img alt="Landing Page" src="img/cc4a4303f4948090.png"></p>
<h2 is-upgraded>Test the DonutCard and DonutList (pt.2)</h2>
<p>Initially you should see the filtered donut list only showing the &#34;classic&#34; donuts - matching the default selection on the <strong>DonutFilterBar</strong>. Now tap on any of the other filter bar items; the selection gets stored in the <strong>DonutService</strong>, which does the filtered based on this selection; stores the new filtered values internally and calls <strong>notifyListeners</strong> so any interested listeners (in our case, <strong>DonutList</strong>) rebuild themselves and show the relevant information.</p>
<p>Run it again and tap around, you should see it working as expected - performing the filtering! Eureka!!!</p>
<p class="image-container"><img alt="Landing Page" src="img/45f62fba00971cd4.gif"></p>


      </google-codelab-step>
    
      <google-codelab-step label="BONUS: Animate the DonutList list items" duration="0">
        <p>If you want to add yet more interactivity and slickness to your app while giving it a nice touch and make it stand from the rest (and on the cheap!), animations is the way to go.</p>
<p>You saw what we did on the <strong>DonutFilterBar</strong> as well as the <strong>DonutPager</strong>, where even the slightest detail made a noticeable difference. We&#39;ll do the same with the <strong>DonutList</strong> items by changing the way they get shown on the list and add some sort of animated transition as they come in.</p>
<p class="image-container"><img alt="Landing Page" src="img/2142b5782e3ce0b4.gif"></p>
<p>As you saw in the image provided, the list items get displayed with a fading and sliding animated transition as they enter, so you can imagine that these two animations should be happening in parallel - as it slides in, it starts to fade in. That&#39;s exactly what we will do: add a <strong>SlidingTransition</strong> and <strong>FadeTransition</strong> widget!</p>
<p>Both the <strong>SlidingTransition</strong> and <strong>FadeTransition</strong> widgets are part of the <a href="https://flutter.dev/docs/codelabs/explicit-animations" target="_blank">explicit animations</a> package that comes out of the box with Flutter. At a fundamental level, explicit animations provide you with controls for telling Flutter how to quickly rebuild a widget tree to create the illusion of motion.</p>
<h2 is-upgraded>Refactor the DonutList ListView</h2>
<p>We&#39;ll refactor the existing <strong>ListView.builder</strong> and replace it by an <strong>AnimatedList</strong> widget. The <a href="https://api.flutter.dev/flutter/widgets/AnimatedList-class.html" target="_blank">**AnimatedList</a> widget consists of a scrolling container that animates items as they are inserted or removed. We will leverage the animated capabilites of the <strong>AnimatedList</strong> by inserting the items in a staggered fashion in order to achieve that animation where they gradually appear into view.</p>
<p>First, let&#39;s add a <strong>GlobalKey</strong> reference in the <strong>_DonutListState</strong> class - all <strong>AnimatedList</strong> widgets require a key in order to tap into its inserting capabilities so we can uniquely reference them outside of the <strong>build</strong> method of the enclosing widget.</p>
<p class="image-container"><img alt="Landing Page" src="img/f546266c1f37c8d5.png"></p>
<p>Let&#39;s also create a collection of <strong>DonutModel</strong> references that will serve as the holding collection where we&#39;ll be inserting the items in a staggered manner from the original donuts collection:</p>
<p class="image-container"><img alt="Landing Page" src="img/997cffcce623f74c.png"></p>
<p>Next, go to the <strong>build</strong> method and do the following replacements:</p>
<ul>
<li>Replace the <strong>ListView.builder</strong> call by a reference to <strong>AnimatedList</strong></li>
<li>replace <strong>itemCount</strong> by <strong>initialItemCount</strong>; instead of the value being <strong>widget.donuts.length</strong>, change it to <strong>insertedItems.length</strong>, since we&#39;ll be inserting items in a staggered way</li>
<li>add the new property <strong>key</strong> and set it to our newly created <strong>GlobalKey </strong><strong><em>_key</em></strong></li>
<li>to the existing <strong>itemBuilder</strong> callback method which contains two parameters (<strong><em>context</em></strong> and <strong><em>index</em></strong>) add an additional parameter at the end, named <strong><em>animation</em></strong>. The <strong>AnimatedList</strong> provides this additional parameter via the <strong>itemBuilder</strong> callback for that same purpose - to add animation capabilities to each of its list items. This parameter is type <strong>AnimationController</strong> which can be fed into your animation scheme for each list item in turn. We&#39;ll show  you how to leverage it.</li>
</ul>
<p>Your new <strong>AnimatedList</strong> code should look like this:</p>
<p class="image-container"><img alt="Landing Page" src="img/117da0d65c26c8b9.png"></p>
<p>Let&#39;s now implement the logic of how to add the items to the <strong>insertedItems</strong> list in a staggered fashion. We&#39;ll achieve it by introducing a small delay between inserts (about 125 milliseconds). We&#39;ll use <strong>Futures</strong> for this.</p>
<p>Override the <strong>initState</strong> method in the <strong>_DonutListState</strong> class, so we can do some needed initializations:</p>
<p class="image-container"><img alt="Landing Page" src="img/8786b8abd4efc6f9.png"></p>
<p>Inside of the <strong>initState</strong> method, create a loop that runs for the length of provided donut items in the <strong>widget.donuts</strong> collection, and for each iteration, create a <strong>Future</strong> object with a 125 ms. delay, inserted in the holding collection <strong>insertedItems</strong> as well as insert the corresponding index directly to the <strong>AnimatedList</strong> (via the <strong>GlobalKey</strong> reference, i.e. <strong><em>key.currentState!.insertItem</em></strong>). This is done so that the <strong>AnimatedList</strong> knows how to reference how many items are in its internal collection in regards to the actual collection of list items to be animated:</p>
<p class="image-container"><img alt="Landing Page" src="img/cfb31b3fac706bea.png"></p>
<p>To recap: what will happen is that:</p>
<ul>
<li>each item will be inserted from the main collection (widget.donuts) to a holding collection (insertedItems)</li>
<li>as they are inserted, we introduce a delay of 125 ms.</li>
<li>The <strong>AnimatedList</strong> widget receives one at a time within 125 ms. from each other, and performs whatever animation you decide to do on them within the <strong>itemBuilder</strong> callback method, provided the <strong>animation</strong> parameter, which we&#39;ll get to in a minute.</li>
</ul>
<p>If you try to run the code as-is now, you&#39;ll see them pop in, one after the other, with a 125 ms. time difference from each other, since there is no animation.</p>
<p class="image-container"><img alt="Landing Page" src="img/50c88bcbe560245b.gif"></p>
<p>Let&#39;s now implement the animation and leverage all we&#39;ve done so far. In order to achieve the desired effect, we will have to wrap our <strong>DonutCard</strong> inside a <strong>FadeTransition</strong> inside a <strong>SlideTransition</strong>. Let&#39;s see how it&#39;s done.</p>
<p>Back in the <strong>build</strong> method of the <strong>DonutList</strong> widget, inside the <strong>AnimatedList </strong></p>
<p><strong><em>itemBuilder</em></strong> callback, wrap the <strong>DonutCard</strong> being returned inside a <strong>FadeTransition</strong> widget:</p>
<p class="image-container"><img alt="Landing Page" src="img/b662b32f4fbfd35.png"></p>
<p>Let&#39;s dissect this code for a sec:</p>
<ul>
<li>The <strong>FadeTransition</strong> widget takes a <strong>child</strong>, which will be the widget on which to apply the transition to</li>
<li>opacity: instead of just a single value, it takes an <strong>Animation</strong> object from the result of calling <strong>animate</strong> on a <a href="https://api.flutter.dev/flutter/animation/Tween-class.html" target="_blank"><strong>Tween</strong></a> object, in which you define the bounds of the animation (the begin and the end)</li>
<li>Tween: pass two values:  <ul>
<li>begin: (0.0)</li>
<li>end: (1.0) This means run the full animation from beginning to end in the opacity spectrum (from totally invisible to fully visible)</li>
</ul>
</li>
<li>On the Tween object: call the method <strong>animate</strong>, to which you pass a <strong>CurvedAnimation</strong>  with the following values:  <ul>
<li>curve: the animation curve (Curves.easeInOut)</li>
<li>parent: the animation to which this animation applies the curve</li>
</ul>
</li>
</ul>
<aside class="special"><p>Want to know more about animations in Flutter! Follow this <a href="https://flutter.dev/docs/development/ui/animations" target="_blank">link</a>.</p>
</aside>
<p>Running the code as-is, shows us just the fading transition - the items show one at a time, at least in a smooth fading fashion.</p>
<p class="image-container"><img alt="Landing Page" src="img/fea2b616c0e310a3.gif"></p>
<p>Let&#39;s wrap it up by adding the final touch, which is adding the sliding animation. In order to make the animations run in parallel, just wrap one inside the other. In this case, wrap the current <strong>FadeTransition</strong> into a <strong>SlideTransition</strong> widget, as follows:</p>
<p class="image-container"><img alt="Landing Page" src="img/38160efca4b3bdfc.png"></p>
<p>Dissecting the code as well, it is pretty similar to the <strong>FadeTransition</strong> widget, with the only difference that the <strong>Tween</strong> object takes an <strong>Offset</strong> (an x and y coordinate in a 2D plane) object instead of a single value (1 or 0, for opacity).</p>
<p>What we&#39;re stating by providing a <strong>Tween</strong> with a <strong><em>begin</em></strong> (0.2, 0.0) and an <strong><em>end</em></strong> of (0.0, 0.0) is that we want a sliding transition, where the x-axis moves from 0.2 (20% of its original position) back to 0 (its original position), while the y-axis remains constant during the transition.</p>
<p>Running this code once again on DartPad and you should see the full-blown animation, both sliding and fading, as the items enter the screen (behind the scene getting inserted in real-time ;)), giving it a nice animated transition.</p>
<p class="image-container"><img alt="Landing Page" src="img/2142b5782e3ce0b4.gif"></p>
<p>And with that we&#39;ve concluded the coding of our landing page. In the next codelab we will tackle the <strong>DonutShopDetails</strong> widget page, so keep pushing along!</p>
<p>Thank you for making this far - hope you&#39;ve enjoyed these codelabs so far!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Wrap-up" duration="0">
        <p>And with that, we wrap up codelab #2 of this series, where we accomplished the following:</p>
<ul>
<li>Created a Landing Page</li>
<li>Created a Bottom Navigation Bar Widget</li>
<li>Created the AppBar</li>
<li>Created a custom Drawer widget</li>
<li>Created models and mocked data that fed these widgets</li>
<li>Created a custom PageViewer using the core PageView and added custom page view indicators</li>
<li>State Management using Provider (MultiProvider, ChangeNotifierProvider, ChangeNotifier, Consumer, notifyListeners)</li>
<li>Nested Navigation using the Navigator Widget</li>
<li>More on Animations using explicit animation widgets (i.e. SlidingTransition, FadeTransition)</li>
</ul>
<p>In <a href="https://romanejaquez.github.io/flutter-codelab-cr2-3" target="_blank">codelab #3</a> of this series, we&#39;ll be tackling the details page of this application, so continue your journey!</p>
<h3 is-upgraded>Please don&#39;t forget to follow me on social media:</h3>
<ul>
<li>On Twitter (<a href="https://www.twitter.com/drcoderz" target="_blank">@drcoderz</a>)</li>
<li>On YouTube (<a href="https://www.youtube.com/channel/UCKsp3r1ERjCpKJtD2n5WtPg" target="_blank">Roman Just Codes</a>)</li>
<li>On My <a href="https://romanjustcodes.web.app/#/home" target="_blank">Personal Portfolio</a></li>
<li>On <a href="https://medium.com/@romanejaquez" target="_blank">Medium</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Complete Code" duration="0">
        <p>In case you fell behind on this codelab, below is the whole code for this codelab in a way you can copy / paste directly into DartPad:</p>
<pre><code language="language-flutter" class="language-flutter">import &#39;package:flutter/material.dart&#39;;
import &#39;package:provider/provider.dart&#39;;

void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (_) =&gt; DonutBottomBarSelectionService(),
        ),
        ChangeNotifierProvider(
          create: (_) =&gt; DonutService(),
        )
      ],
      child: MaterialApp(
        debugShowCheckedModeBanner: false,
        initialRoute: &#39;/&#39;,
        navigatorKey: Utils.mainAppNav,
        routes: {
          &#39;/&#39;: (context) =&gt; SplashPage(),
          &#39;/main&#39;: (context) =&gt; DonutShopMain()
        }
      )
    )
  ); 
}

class SplashPage extends StatefulWidget {

  @override 
  SplashPageState createState() =&gt; SplashPageState();
}

class SplashPageState extends State&lt;SplashPage&gt; 
  with SingleTickerProviderStateMixin {

  AnimationController? donutController;
  Animation&lt;double&gt;? rotationAnimation;

  @override
  void initState() {
    super.initState();
    donutController = AnimationController(
      duration: const Duration(seconds: 5), 
      vsync: this)..repeat();

    rotationAnimation = Tween&lt;double&gt;(begin: 0, end: 1)
    .animate(CurvedAnimation(parent: donutController!, curve: Curves.linear));
  }

  @override 
  void dispose() {
    donutController!.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {

    Future.delayed(const Duration(seconds: 2), () {
      Utils.mainAppNav.currentState!.pushReplacementNamed(&#39;/main&#39;);
    });

    return Scaffold(
      backgroundColor: Utils.mainColor,
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            RotationTransition(
              turns: rotationAnimation!,
              child: Image.network(Utils.donutLogoWhiteNoText, width: 100, height: 100),
            ),
            Image.network(Utils.donutLogoWhiteText, width: 150, height: 150)
          ],
        ),
      )
    );
  }
}

class DonutShopMain extends StatelessWidget {

  @override 
  Widget build(BuildContext context) {
    return Scaffold(
      drawer: Drawer(
        child: DonutSideMenu()
      ),
      appBar: AppBar(
        iconTheme: const IconThemeData(color: Utils.mainDark),
        backgroundColor: Colors.transparent,
        elevation: 0,
        centerTitle: true,
        title: Image.network(Utils.donutLogoRedText, width: 120)
      ),
      body: Column(
        children: [
          Expanded(
            child: Navigator(
              key: Utils.mainListNav,
              initialRoute: &#39;/main&#39;,
              onGenerateRoute: (RouteSettings settings) {
                Widget page;
                switch(settings.name) {
                  case &#39;/main&#39;:
                    page = DonutMainPage();
                    break;
                  case &#39;/favorites&#39;:
                    page = Center(child: Text(&#39;favorites&#39;));
                    break;
                  case &#39;/shoppingcart&#39;:
                    page = Center(child: Text(&#39;shopping cart&#39;));
                    break;
                  default:
                    page = Center(child: Text(&#39;main&#39;));
                    break;
                }

                return PageRouteBuilder(pageBuilder: (_, __, ___) =&gt; page,
                  transitionDuration: const Duration(seconds: 0)
                );
             }
             
           )


          ),
          DonutBottomBar()
        ]
      )
    );
  }
}

class DonutMainPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        DonutPager(),
        DonutFilterBar(),
        Expanded(
          child: Consumer&lt;DonutService&gt;(
            builder: (context, donutService, child) {
              return DonutList(donuts: donutService.filteredDonuts);
            },
          )
        )
      ]
    );
  }
}

class DonutPager extends StatefulWidget {
  @override
  State&lt;DonutPager&gt; createState() =&gt; _DonutPagerState();
}

class _DonutPagerState extends State&lt;DonutPager&gt; {

  List&lt;DonutPage&gt; pages = [
    DonutPage(imgUrl: Utils.donutPromo1, logoImgUrl: Utils.donutLogoWhiteText),
    DonutPage(imgUrl: Utils.donutPromo2, logoImgUrl: Utils.donutLogoWhiteText),
    DonutPage(imgUrl: Utils.donutPromo3, logoImgUrl: Utils.donutLogoRedText),
  ];

  int currentPage = 0;
  PageController? controller;

  @override
  void initState() {
    controller = PageController(initialPage: 0);
    super.initState();
  }

  @override
  void dispose() {
    controller!.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 350,
      child: Column(
        children: [
          Expanded(
            child: PageView(
              scrollDirection: Axis.horizontal,
              pageSnapping: true,
              controller: controller,
              onPageChanged: (int page) {
                setState(() {
                  currentPage = page;
                });
              },
              children: List.generate(pages.length, (index) {
                DonutPage currentPage = pages[index];
                return Container(
                  alignment: Alignment.bottomLeft,
                  margin: EdgeInsets.all(20),
                  padding: EdgeInsets.all(30),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(30),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.2), 
                        blurRadius: 10, 
                        offset: Offset(0.0, 5.0)
                      )
                    ],
                    image: DecorationImage(
                      image: NetworkImage(currentPage.imgUrl!),
                      fit: BoxFit.cover
                    )
                  ),
                  child: Image.network(currentPage.logoImgUrl!, width: 120)
                );
              })
            )
          ),
          PageViewIndicator(
            controller: controller, 
            numberOfPages: pages.length,
            currentPage: currentPage,
          )
        ],
      )
    );
  }
}

class PageViewIndicator extends StatelessWidget {
  
  PageController? controller;
  int? numberOfPages;
  int? currentPage;

  PageViewIndicator({ this.controller, this.numberOfPages, this.currentPage });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: List.generate(numberOfPages!, (index) {

        return GestureDetector(  
          onTap: () {
            controller!.animateToPage(
              index, 
              duration: const Duration(milliseconds: 500), 
              curve: Curves.easeInOut);
          },
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 250),
            curve: Curves.easeInOut,
            width: 15,
            height: 15,
            margin: EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: currentPage == index ? 
                Utils.mainColor : Colors.grey.withOpacity(0.2),
              borderRadius: BorderRadius.circular(10)
            )
          )
        );

        
      })
    );
  }
 
}

class DonutSideMenu extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Utils.mainDark,
      padding: EdgeInsets.all(40),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Container(
            margin: EdgeInsets.only(top: 40),
            child: Image.network(Utils.donutLogoWhiteNoText,
              width: 100
            )
          ),
          Image.network(Utils.donutLogoWhiteText,
            width: 150
          )
        ],
      )
    );
  }
}

class DonutBottomBar extends StatelessWidget {

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.all(30),
      child: Consumer&lt;DonutBottomBarSelectionService&gt;(
        builder: (context, bottomBarSelectionService, child) {
          return Row(
            crossAxisAlignment: CrossAxisAlignment.end,
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: Icon(
                  Icons.trip_origin, 
                  color: bottomBarSelectionService.tabSelection == &#39;main&#39; ? 
                            Utils.mainDark : Utils.mainColor
                ),
                onPressed: () {
                  bottomBarSelectionService.setTabSelection(&#39;main&#39;);
                }
              ),
              IconButton(
                icon: Icon(Icons.favorite, 
                color: bottomBarSelectionService.tabSelection == &#39;favorites&#39; ? 
                            Utils.mainDark : Utils.mainColor
                ),
                onPressed: () {
                  bottomBarSelectionService.setTabSelection(&#39;favorites&#39;);
                }
              ),
              IconButton(
                icon: Icon(Icons.shopping_cart,
                color: bottomBarSelectionService.tabSelection == &#39;shoppingcart&#39; ? 
                            Utils.mainDark : Utils.mainColor
                ),
                onPressed: () {
                  bottomBarSelectionService.setTabSelection(&#39;shoppingcart&#39;);
                }
              )
            ]
          );
      })
    );
  }
}

class DonutFilterBar extends StatelessWidget {

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.all(20),
      child: Consumer&lt;DonutService&gt;(
        builder: (context, donutService, child) {
          return Column(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: List.generate(
                  donutService.filterBarItems.length, (index) {

                    DonutFilterBarItem item = donutService.filterBarItems[index];

                    return  GestureDetector(
                      onTap: () { 
                        donutService.filteredDonutsByType(item.id!);
                      },
                      child: Container(
                        child: Text(&#39;${item.label!}&#39;, 
                        style: TextStyle(
                          color: donutService.selectedDonutType == item.id ? 
                          Utils.mainColor : Colors.black, fontWeight: FontWeight.bold)
                        )
                      )
                    );
                  }
                )
              ),
              SizedBox(height: 10),
              Stack(
                children: [
                  AnimatedAlign(
                    duration: const Duration(milliseconds: 250),
                    curve: Curves.easeInOut,
                    alignment: alignmentBasedOnTap(donutService.selectedDonutType),
                    child: Container(
                      width: MediaQuery.of(context).size.width / 3 - 20,
                      height: 5,
                      decoration: BoxDecoration(
                        color: Utils.mainColor,
                        borderRadius: BorderRadius.circular(20)
                      )
                    )
                  )
                ],
              )
            ]
          );
        }
      )
    );
  }

  Alignment alignmentBasedOnTap(filterBarId) {
    
    switch(filterBarId) {
      case &#39;classic&#39;:
        return Alignment.centerLeft;
      case &#39;sprinkled&#39;:
        return Alignment.center;
      case &#39;stuffed&#39;:
        return Alignment.centerRight;
      default:
        return Alignment.centerLeft;
    }
  }
}

class DonutList extends StatefulWidget {
  List&lt;DonutModel&gt;? donuts;

  DonutList({ this.donuts });

  @override
  State&lt;DonutList&gt; createState() =&gt; _DonutListState();
}

class _DonutListState extends State&lt;DonutList&gt; {
  final GlobalKey&lt;AnimatedListState&gt; _key = GlobalKey();
  List&lt;DonutModel&gt; insertedItems = [];

  @override 
  void initState() {
    super.initState();

    var future = Future(() {});
    for (var i = 0; i &lt; widget.donuts!.length; i++) {
      future = future.then((_) {
        return Future.delayed(const Duration(milliseconds: 125), () {
          insertedItems.add(widget.donuts![i]);
          _key.currentState!.insertItem(i);
        });
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedList(
      key: _key,
      scrollDirection: Axis.horizontal,
      initialItemCount: insertedItems.length,
      itemBuilder: (context, index, animation) {
        
        DonutModel currentDonut = widget.donuts![index];

        return SlideTransition(
          position: Tween(
            begin: const Offset(0.2, 0.0),
            end: const Offset(0.0, 0.0),
          ).animate(CurvedAnimation(parent: animation, curve: Curves.easeInOut)),
          child: FadeTransition(
            opacity: Tween(begin: 0.0, end: 1.0)
            .animate(CurvedAnimation(
              parent: animation, curve: Curves.easeInOut)
            ),
            child: DonutCard(donutInfo: currentDonut)
          )
        );
      }
    );
  }
}

class DonutCard extends StatelessWidget {
  DonutModel? donutInfo;
  DonutCard({ this.donutInfo });

  @override
  Widget build(BuildContext context) {
    return Stack(
      alignment: Alignment.center,
      children: [
        Container(
          width: 150,
          padding: EdgeInsets.all(15),
          alignment: Alignment.bottomLeft,
          margin: EdgeInsets.only(left: 10, top: 80, right: 10, bottom: 20),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(20),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05), 
                blurRadius: 10, 
                offset: Offset(0.0, 4.0)
              )
            ]
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.end,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(&#39;${donutInfo!.name}&#39;, 
                style: TextStyle(
                  color: Utils.mainDark, 
                  fontWeight: FontWeight.bold, 
                  fontSize: 15
                )
              ),
              SizedBox(height: 10),
              Container(
                decoration: BoxDecoration(
                  color: Utils.mainColor,
                  borderRadius: BorderRadius.circular(20),
                ),
                padding: EdgeInsets.only(
                  left: 10, right: 10, top: 5, bottom: 5
                ),
                child: Text(&#39;\$${donutInfo!.price!.toStringAsFixed(2)}&#39;, 
                  style: TextStyle(
                    fontSize: 12, 
                    color: Colors.white, 
                    fontWeight: FontWeight.bold
                  )
                )
              )
            ]
          ),
        ),
        Align(
          alignment: Alignment.topCenter,
          child: Image.network(
            donutInfo!.imgUrl!, 
            width: 150, height: 150, 
            fit: BoxFit.contain
          ),
        )
      ]
    );
  }
}

class DonutBottomBarSelectionService extends ChangeNotifier {

  String? tabSelection = &#39;main&#39;;

  void setTabSelection(String selection) {
    Utils.mainListNav.currentState!.pushReplacementNamed(&#39;/&#39; + selection);
    tabSelection = selection;
    notifyListeners();
  }
}

class DonutService extends ChangeNotifier {

  List&lt;DonutFilterBarItem&gt; filterBarItems = [
    DonutFilterBarItem(id: &#39;classic&#39;, label: &#39;Classic&#39;),
    DonutFilterBarItem(id: &#39;sprinkled&#39;, label: &#39;Sprinkled&#39;),
    DonutFilterBarItem(id: &#39;stuffed&#39;, label: &#39;Stuffed&#39;),
  ];

  String? selectedDonutType;
  List&lt;DonutModel&gt; filteredDonuts = [];

  DonutService() {
    selectedDonutType = filterBarItems.first.id;
    filteredDonutsByType(selectedDonutType!);
  }

  void filteredDonutsByType(String type) {
    selectedDonutType = type;
    filteredDonuts = Utils.donuts.where(
      (d) =&gt; d.type == selectedDonutType).toList();

    notifyListeners();
  }


}

class DonutFilterBarItem {
  String? id;
  String? label;

  DonutFilterBarItem({ this.id, this.label });
}

class DonutPage {
  String? imgUrl;
  String? logoImgUrl;
  
  DonutPage({ this.imgUrl, this.logoImgUrl });
}

class DonutModel {

  String? imgUrl;
  String? name;
  String? description;
  double? price;
  String? type;

  DonutModel({
    this.imgUrl,
    this.name,
    this.description,
    this.price,
    this.type
  });
}

class Utils {
  static GlobalKey&lt;NavigatorState&gt; mainListNav = GlobalKey();
  static GlobalKey&lt;NavigatorState&gt; mainAppNav = GlobalKey();

  static const Color mainColor = Color(0xFFFF0F7E);
  static const Color mainDark = Color(0xFF980346);
  static const String donutLogoWhiteNoText = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_shop_logowhite_notext.png&#39;;
  static const String donutLogoWhiteText = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_shop_text_reversed.png&#39;;
  static const String donutLogoRedText = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_shop_text.png&#39;;
  static const String donutTitleFavorites = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_favorites_title.png&#39;;
  static const String donutTitleMyDonuts = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_mydonuts_title.png&#39;;
  static const String donutPromo1 = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_promo1.png&#39;;
  static const String donutPromo2 = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_promo2.png&#39;;
  static const String donutPromo3 = &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donut_promo3.png&#39;;

  static List&lt;DonutModel&gt; donuts = [
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic1.png&#39;,
      name: &#39;Strawberry Sprinkled Glazed&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic2.png&#39;,
      name: &#39;Chocolate Glazed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;classic&#39;,
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic3.png&#39;,
      name: &#39;Chocolate Dipped Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic4.png&#39;,
      name: &#39;Cinamon Glazed Glazed&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutclassic/donut_classic5.png&#39;,
      name: &#39;Sugar Glazed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;classic&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled1.png&#39;,
      name: &#39;Halloween Chocolate Glazed&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled2.png&#39;,
      name: &#39;Party Sprinkled Cream&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled3.png&#39;,
      name: &#39;Chocolate Glazed Sprinkled&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled4.png&#39;,
      name: &#39;Strawbery Glazed Sprinkled&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutsprinkled/donut_sprinkled5.png&#39;,
      name: &#39;Reese\&#39;s Sprinkled&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 3.99,
      type: &#39;sprinkled&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed1.png&#39;,
      name: &#39;Brownie Cream Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed2.png&#39;,
      name: &#39;Jelly Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.99,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed3.png&#39;,
      name: &#39;Caramel Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 2.59,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed4.png&#39;,
      name: &#39;Maple Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.99,
      type: &#39;stuffed&#39;
    ),
    DonutModel(
      imgUrl: &#39;https://romanejaquez.github.io/flutter-codelab4/assets/donutstuffed/donut_stuffed5.png&#39;,
      name: &#39;Glazed Jelly Stuffed Doughnut&#39;,
      description: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit, tellus condimentum cursus gravida, lorem augue venenatis elit, sit amet bibendum quam neque id sapien.&#39;,
      price: 1.59,
      type: &#39;stuffed&#39;
    )
  ];
}    

</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements-tmp/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements-tmp/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements-tmp/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements-tmp/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.slim.js" integrity="sha256-HwWONEZrpuoh951cQD1ov2HUK5zA5DwJ1DNUXaM6FsY=" crossorigin="anonymous"></script>
  <script>
    $(function() {
      $('#done').removeAttr('href');
      $('#done').css('cursor', 'pointer');
      $('#done').click(function () { 
        window.location.href = 'https://romanjustcodes.web.app/#/workshops';
      });
    });
  </script>
</body>
</html>
